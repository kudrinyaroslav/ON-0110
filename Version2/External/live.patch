diff -Naur original\live/build/live.vcproj live/build/live.vcproj
--- original\live/build/live.vcproj	1970-01-01 03:00:00.000000000 +0300
+++ live/build/live.vcproj	2014-12-08 17:23:43.293551100 +0300
@@ -0,0 +1,849 @@
+<?xml version="1.0" encoding="gb2312"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="live"
+	ProjectGUID="{7885F4C0-973A-42A2-AA41-EFF0D45BDC14}"
+	SccProjectName="SAK"
+	SccAuxPath="SAK"
+	SccLocalPath="SAK"
+	SccProvider="SAK"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="..\liveMedia\include,..\BasicUsageEnvironment\include,..\groupsock\include,..\UsageEnvironment\include"
+				PreprocessorDefinitions="_LIB;CRTAPI1=_cdecl;CRTAPI2=_cdecl;_X86_=1;_WIN95;_WIN32_WINDOWS=0x0400;_WIN32_IE=0x0300;WINVER=0x0400;WIN32;_WIN32;WINNT;_WINNT;_MT;_CRT_SECURE_NO_WARNINGS"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\..\..\build\livelib\release\obj/live.pch"
+				AssemblerListingLocation=".\..\..\build\livelib\release\obj/"
+				ObjectFile=".\..\..\build\livelib\release\obj/"
+				ProgramDataBaseFileName=".\..\..\build\livelib\release\obj/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalDependencies="WS2_32.Lib"
+				OutputFile="..\..\..\TestTool\Lib\live.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\..\..\build\livelib\release/live.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\liveMedia\include,..\BasicUsageEnvironment\include,..\groupsock\include,..\UsageEnvironment\include"
+				PreprocessorDefinitions="_LIB;CRTAPI1=_cdecl;CRTAPI2=_cdecl;_X86_=1;_WIN95;_WIN32_WINDOWS=0x0400;_WIN32_IE=0x0300;WINVER=0x0400;WIN32;_WIN32;WINNT;_WINNT;_MT;DBG=1;DEBUG;_DEBUG;_CRT_SECURE_NO_WARNINGS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				PrecompiledHeaderFile=""
+				AssemblerListingLocation=".\..\..\build\livelib\debug\obj/"
+				ObjectFile=".\..\..\build\livelib\debug\obj/"
+				ProgramDataBaseFileName=".\..\..\build\livelib\debug\obj/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalDependencies="WS2_32.Lib"
+				OutputFile="..\..\..\TestTool\Lib\debug\live.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\..\..\build\livelib\debug/live.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Groupsock"
+			>
+			<File
+				RelativePath="..\groupsock\GroupEId.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\groupsock\Groupsock.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\groupsock\GroupsockHelper.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\groupsock\inet.c"
+				>
+			</File>
+			<File
+				RelativePath="..\groupsock\IOHandlers.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\groupsock\NetAddress.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\groupsock\NetInterface.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="BasicUsageEnv"
+			>
+			<File
+				RelativePath="..\BasicUsageEnvironment\BasicHashTable.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\BasicUsageEnvironment\BasicTaskScheduler.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\BasicUsageEnvironment\BasicTaskScheduler0.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\BasicUsageEnvironment\BasicUsageEnvironment.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\BasicUsageEnvironment\BasicUsageEnvironment0.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\BasicUsageEnvironment\DelayQueue.cpp"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="LiveMedia"
+			>
+			<File
+				RelativePath="..\liveMedia\AC3AudioRTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\AC3AudioRTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\AC3AudioStreamFramer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\ADTSAudioFileServerMediaSubsession.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\ADTSAudioFileSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\AMRAudioFileServerMediaSubsession.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\AMRAudioFileSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\AMRAudioFileSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\AMRAudioRTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\AMRAudioRTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\AMRAudioSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\AudioInputDevice.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\AudioRTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\AVIFileSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\Base64.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\BasicUDPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\BasicUDPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\BitVector.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\BitVector.hh"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\ByteStreamFileSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\ByteStreamMultiFileSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\DarwinInjector.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\DeviceSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\DigestAuthentication.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\DVVideoRTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\DVVideoStreamFramer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\FileServerMediaSubsession.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\FileSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\FramedFileSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\FramedFilter.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\FramedSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\GSMAudioRTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\H261VideoRTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\H263plusVideoFileServerMediaSubsession.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\H263plusVideoRTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\H263plusVideoRTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\H263plusVideoStreamFramer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\H263plusVideoStreamParser.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\H263plusVideoStreamParser.hh"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\H264VideoFileSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\H264VideoRTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\H264VideoRTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\H264VideoStreamFramer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\HTTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\InputFile.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\JPEGVideoRTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\JPEGVideoRTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\JPEGVideoSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\Locale.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\Media.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MediaSession.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MediaSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MediaSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3ADU.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3ADUdescriptor.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3ADUdescriptor.hh"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3ADUinterleaving.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3ADURTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3ADURTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3ADUTranscoder.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3AudioFileServerMediaSubsession.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3FileSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3HTTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3Internals.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3Internals.hh"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3InternalsHuffman.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3InternalsHuffman.hh"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3InternalsHuffmanTable.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3StreamState.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3StreamState.hh"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MP3Transcoder.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG1or2AudioRTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG1or2AudioRTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG1or2AudioStreamFramer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG1or2Demux.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG1or2DemuxedElementaryStream.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG1or2DemuxedServerMediaSubsession.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG1or2FileServerDemux.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG1or2VideoFileServerMediaSubsession.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG1or2VideoHTTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG1or2VideoRTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG1or2VideoRTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG1or2VideoStreamDiscreteFramer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG1or2VideoStreamFramer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG2IndexFromTransportStream.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG2TransportFileServerMediaSubsession.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG2TransportStreamFramer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG2TransportStreamFromESSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG2TransportStreamFromPESSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG2TransportStreamIndexFile.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG2TransportStreamMultiplexor.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG2TransportStreamTrickModeFilter.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG4ESVideoRTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG4ESVideoRTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG4GenericRTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG4GenericRTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG4LATMAudioRTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG4LATMAudioRTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG4VideoFileServerMediaSubsession.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG4VideoStreamDiscreteFramer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEG4VideoStreamFramer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEGVideoStreamFramer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEGVideoStreamParser.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MPEGVideoStreamParser.hh"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MultiFramedRTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\MultiFramedRTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\OnDemandServerMediaSubsession.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\our_md5.c"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\our_md5.h"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\our_md5hl.c"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\OutputFile.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\PassiveServerMediaSubsession.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\QCELPAudioRTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\QuickTimeFileSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\QuickTimeGenericRTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\RTCP.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\rtcp_from_spec.c"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\rtcp_from_spec.h"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\RTPInterface.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\RTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\RTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\RTSPClient.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\RTSPCommon.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\RTSPOverHTTPServer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\RTSPServer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\ServerMediaSession.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\SimpleRTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\SimpleRTPSource.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\SIPClient.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\StreamParser.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\StreamParser.hh"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\uLawAudioFilter.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\VideoRTPSink.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\WAVAudioFileServerMediaSubsession.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\liveMedia\WAVAudioFileSource.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="BasicUsage"
+			>
+			<File
+				RelativePath="..\UsageEnvironment\HashTable.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\UsageEnvironment\strDup.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\UsageEnvironment\UsageEnvironment.cpp"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur original\live/groupsock/GroupEId.cpp live/groupsock/GroupEId.cpp
--- original\live/groupsock/GroupEId.cpp	2009-11-27 13:25:55.000000000 +0300
+++ live/groupsock/GroupEId.cpp	2014-11-30 14:36:25.980147100 +0300
@@ -26,11 +26,14 @@
 void Scope::assign(u_int8_t ttl, const char* publicKey) {
   fTTL = ttl;
 
-  fPublicKey = strDup(publicKey == NULL ? "nokey" : publicKey);
+  //fPublicKey = strDup(publicKey == NULL ? "nokey" : publicKey);
+  fPublicKey = (publicKey == NULL ? NULL : strDup(publicKey));
 }
 
 void Scope::clean() {
-  delete[] fPublicKey;
+  if (fPublicKey != NULL) {
+    delete[] fPublicKey;
+  }
   fPublicKey = NULL;
 }
 
@@ -102,3 +105,28 @@
   fPortNum = portNum;
   fScope = scope;
 }
+
+#ifdef LIVE_SUPPORT_IPV6_UDP
+GroupEId::GroupEId(NetAddress const& groupAddr,
+		   portNumBits portNum, Scope const& scope,
+		   unsigned numSuccessiveGroupAddrs) {
+  NetAddress sourceFilterAddr;
+  init(groupAddr, sourceFilterAddr, portNum, scope, numSuccessiveGroupAddrs);
+}
+
+void GroupEId::init(NetAddress const& groupAddr,
+  NetAddress const& sourceFilterAddr,
+  portNumBits portNum,
+  Scope const& scope,
+  unsigned numSuccessiveGroupAddrs,
+  bool isSSM) {
+    fGroupAddressA = groupAddr;
+    fSourceFilterAddressA = sourceFilterAddr;
+    fNumSuccessiveGroupAddrs = numSuccessiveGroupAddrs;
+    fPortNum = portNum;
+    fScope = scope;
+    fGroupAddress.s_addr = *(u_long*)groupAddr.data();
+    fSourceFilterAddress.s_addr = isSSM ? *(u_long*)sourceFilterAddr.data() : ~0;
+}
+
+#endif
diff -Naur original\live/groupsock/Groupsock.cpp live/groupsock/Groupsock.cpp
--- original\live/groupsock/Groupsock.cpp	2009-11-27 13:25:55.000000000 +0300
+++ live/groupsock/Groupsock.cpp	2014-11-30 14:36:25.988147600 +0300
@@ -39,6 +39,14 @@
     fSourcePort(0), fLastSentTTL(0) {
 }
 
+#ifdef LIVE_SUPPORT_IPV6
+OutputSocket::OutputSocket(UsageEnvironment& env, Port port, int AF)
+  : Socket(env, port, True, AF),
+    fSourcePort(0), fLastSentTTL(0)
+{
+}
+#endif
+
 OutputSocket::~OutputSocket() {
 }
 
@@ -86,6 +94,13 @@
   : fNext(next), fGroupEId(addr, port.num(), ttl), fPort(port) {
 }
 
+#ifdef LIVE_SUPPORT_IPV6_UDP
+destRecord::destRecord(NetAddress const& addr, Port const& port, u_int8_t ttl, destRecord* next)
+  : fNext(next), fGroupEId(addr, port.num(), ttl), fPort(port)
+{
+}
+#endif
+
 destRecord::~destRecord() {
   delete fNext;
 }
@@ -104,6 +119,7 @@
   : OutputSocket(env, port),
     deleteIfNoMembers(False), isSlave(False),
     fIncomingGroupEId(groupAddr, port.num(), ttl), fDests(NULL), fTTL(ttl) {
+  fMembers = new DirectedNetInterfaceSet();
   addDestination(groupAddr, port);
 
   if (!socketJoinGroup(env, socketNum(), groupAddr.s_addr)) {
@@ -132,6 +148,7 @@
     deleteIfNoMembers(False), isSlave(False),
     fIncomingGroupEId(groupAddr, sourceFilterAddr, port.num()),
     fDests(NULL), fTTL(255) {
+  fMembers = new DirectedNetInterfaceSet();
   addDestination(groupAddr, port);
 
   // First try a SSM join.  If that fails, try a regular join:
@@ -153,6 +170,35 @@
   if (DebugLevel >= 2) env << *this << ": created\n";
 }
 
+#ifdef LIVE_SUPPORT_IPV6_UDP
+u_int32_t Groupsock::NIC = ~0;
+Groupsock::Groupsock(UsageEnvironment& env, NetAddress const& groupAddr, Port port, u_int8_t ttl, u_int32_t nicIndex)
+  : OutputSocket(env, port, groupAddr.IsNotZero() ? groupAddr.GetAF() : g_AF),
+    deleteIfNoMembers(False), isSlave(False),
+    fIncomingGroupEId(groupAddr, port.num(), ttl), fDests(NULL), fTTL(ttl), fNIC(Groupsock::NIC == ~0 ? nicIndex : Groupsock::NIC)
+{
+  fMembers = new DirectedNetInterfaceSet();
+  addDestination(groupAddr, port);
+
+  if (!socketJoinGroup(env, socketNum(), groupAddr, fNIC)) {
+    if (DebugLevel >= 1) {
+      env << *this << ": failed to join group: " << env.getResultMsg() << "\n";
+    }
+  }
+
+  if (DebugLevel >= 2) env << *this << ": created\n";
+}
+Groupsock::Groupsock(UsageEnvironment& env, NetAddress const& groupAddr, struct in_addr const& sourceFilterAddr, Port port)
+  : OutputSocket(env, port),
+    deleteIfNoMembers(False), isSlave(False),
+    fIncomingGroupEId(groupAddr, (portNumBits)0, port.num()),
+    fDests(NULL), fTTL(255)
+{
+  // TODO!!!
+}
+#endif
+
+
 Groupsock::~Groupsock() {
   if (isSSM()) {
     if (!socketLeaveGroupSSM(env(), socketNum(), groupAddress().s_addr,
@@ -160,7 +206,11 @@
       socketLeaveGroup(env(), socketNum(), groupAddress().s_addr);
     }
   } else {
+#ifdef LIVE_SUPPORT_IPV6_UDP
+    socketLeaveGroup(env(), socketNum(), fIncomingGroupEId.groupAddressFull(), fNIC);
+#else
     socketLeaveGroup(env(), socketNum(), groupAddress().s_addr);
+#endif
   }
 
   delete fDests;
@@ -205,6 +255,50 @@
   fDests->fGroupEId = GroupEId(destAddr, destPortNum, destTTL);
 }
 
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+void
+Groupsock::changeDestinationParametersFull(NetAddress newDestAddr,
+				       Port newDestPort, int newDestTTL) {
+  if (fDests == NULL) return;
+
+  NetAddress destAddr = fDests->fGroupEId.groupAddressFull();
+  if (newDestAddr.IsNotZero()) {
+    if ((newDestAddr != destAddr) 
+        && IsMulticastAddress(newDestAddr)) {
+      // If the new destination is a multicast address, then we assume that
+      // we want to join it also.  (If this is not in fact the case, then
+      // call "multicastSendOnly()" afterwards.)
+      socketLeaveGroup(env(), socketNum(), destAddr, fNIC);
+      socketJoinGroup(env(), socketNum(), newDestAddr, fNIC);
+    }
+    destAddr = newDestAddr;
+  }
+  
+  portNumBits destPortNum = fDests->fGroupEId.portNum();
+  if (newDestPort.num() != 0) {
+    if ((newDestPort.num() != destPortNum)
+	      && IsMulticastAddress(destAddr)) {
+      // Also bind to the new port number:
+      changePort(newDestPort, destAddr.GetAF());
+      // And rejoin the multicast group:
+      socketJoinGroup(env(), socketNum(), destAddr, fNIC);
+    }
+    destPortNum = newDestPort.num();
+    fDests->fPort = newDestPort;
+  }
+
+  u_int8_t destTTL = ttl();
+  if (newDestTTL != ~0) destTTL = (u_int8_t)newDestTTL;
+  if (GetAF() != newDestAddr.GetAF())
+  {
+    // can't do there, hacking
+    //ChangeAF(newDestAddr.GetAF());
+  }
+  fDests->fGroupEId = GroupEId(newDestAddr, newDestPort.num(), destTTL);
+}
+#endif
+
 void Groupsock::addDestination(struct in_addr const& addr, Port const& port) {
   // Check whether this destination is already known:
   for (destRecord* dests = fDests; dests != NULL; dests = dests->fNext) {
@@ -214,8 +308,26 @@
     }
   }
 
-  fDests = new destRecord(addr, port, ttl(), fDests);
+  destRecord *dest = new destRecord(addr, port, ttl(), fDests);
+  fDests = dest;
+}
+
+#ifdef LIVE_SUPPORT_IPV6_UDP
+void Groupsock::addDestination(NetAddress const& addr, Port const& port)
+{
+  // Check whether this destination is already known:
+  for (destRecord* dests = fDests; dests != NULL; dests = dests->fNext) {
+    if ((addr == dests->fGroupEId.groupAddressFull())
+	      && (port.num() == dests->fPort.num())) {
+      return;
+    }
+  }
+
+  destRecord *dest = new destRecord(addr, port, ttl(), fDests);
+  fDests = dest;
 }
+#endif
+
 
 void Groupsock::removeDestination(struct in_addr const& addr, Port const& port) {
   for (destRecord** destsPtr = &fDests; *destsPtr != NULL;
diff -Naur original\live/groupsock/GroupsockHelper.cpp live/groupsock/GroupsockHelper.cpp
--- original\live/groupsock/GroupsockHelper.cpp	2009-11-27 13:25:55.000000000 +0300
+++ live/groupsock/GroupsockHelper.cpp	2014-11-30 14:36:26.001150200 +0300
@@ -39,6 +39,9 @@
 	env.setResultErrMsg(errorMsg);
 }
 
+// AS Fix default timeout for readSocket
+unsigned int readSocketTimeout = 0;
+
 static int reuseFlag = 1;
 
 NoReuse::NoReuse() {
@@ -55,13 +58,23 @@
 #else
 			Boolean
 #endif
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+       , int AF
+#endif
 ) {
   if (!initializeWinsockIfNecessary()) {
     socketErr(env, "Failed to initialize 'winsock': ");
     return -1;
   }
 
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+  int newSocket = socket(AF, SOCK_DGRAM, 0);
+#else
   int newSocket = socket(AF_INET, SOCK_DGRAM, 0);
+#endif
+
   if (newSocket < 0) {
     socketErr(env, "unable to create datagram socket: ");
     return newSocket;
@@ -104,8 +117,13 @@
   if (port.num() != 0 || ReceivingInterfaceAddr != INADDR_ANY) {
 #endif
     if (port.num() == 0) addr = ReceivingInterfaceAddr;
+#ifdef LIVE_SUPPORT_IPV6_UDP
+    NetAddress adr(AF);
+    if (adr.BindSocket(newSocket, port.num()) != 0) {
+#else
     MAKE_SOCKADDR_IN(name, addr, port.num());
     if (bind(newSocket, (struct sockaddr*)&name, sizeof name) != 0) {
+#endif
       char tmpBuffer[100];
       sprintf(tmpBuffer, "bind() error (port number: %d): ",
 	      ntohs(port.num()));
@@ -148,13 +166,24 @@
 }
 
 int setupStreamSocket(UsageEnvironment& env,
-                      Port port, Boolean makeNonBlocking) {
+                      Port port, Boolean makeNonBlocking
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_TCP
+                      , int AF
+#endif
+                      ) {
   if (!initializeWinsockIfNecessary()) {
     socketErr(env, "Failed to initialize 'winsock': ");
     return -1;
   }
 
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_TCP
+  int newSocket = socket(AF, SOCK_STREAM, 0);
+#else
   int newSocket = socket(AF_INET, SOCK_STREAM, 0);
+#endif
+
   if (newSocket < 0) {
     socketErr(env, "unable to create stream socket: ");
     return newSocket;
@@ -190,8 +219,15 @@
 #else
   if (port.num() != 0 || ReceivingInterfaceAddr != INADDR_ANY) {
 #endif
+
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_TCP
+    NetAddress adr(AF);
+    if (adr.BindSocket(newSocket, port.num()) != 0) {
+#else
     MAKE_SOCKADDR_IN(name, ReceivingInterfaceAddr, port.num());
     if (bind(newSocket, (struct sockaddr*)&name, sizeof name) != 0) {
+#endif
       char tmpBuffer[100];
       sprintf(tmpBuffer, "bind() error (port number: %d): ",
 	      ntohs(port.num()));
@@ -216,7 +252,8 @@
 }
 
 #ifndef IMN_PIM
-static int blockUntilReadable(UsageEnvironment& env,
+// AS fix for concurrect access to reading socket in TCP mode
+int blockUntilReadable(UsageEnvironment& env,
 			      int socket, struct timeval* timeout) {
   int result = -1;
   do {
@@ -255,6 +292,13 @@
 	       struct timeval* timeout) {
   int bytesRead = -1;
   do {
+    struct timeval t1;
+    if (!timeout && readSocketTimeout) {
+      t1.tv_sec = readSocketTimeout;
+      t1.tv_usec = 0;
+      timeout = &t1; 
+    }
+
     int result = blockUntilReadable(env, socket, timeout);
     if (timeout != NULL && result == 0) {
       bytesRead = 0;
@@ -263,10 +307,18 @@
       break;
     }
 
+#ifdef LIVE_SUPPORT_IPV6_UDP
+    sockaddr_in6 _fromAddress;
+    SOCKLEN_T addressSize = sizeof _fromAddress;
+    bytesRead = recvfrom(socket, (char*)buffer, bufferSize, 0,
+      (struct sockaddr*)&_fromAddress,
+      &addressSize);
+#else
     SOCKLEN_T addressSize = sizeof fromAddress;
     bytesRead = recvfrom(socket, (char*)buffer, bufferSize, 0,
 			 (struct sockaddr*)&fromAddress,
 			 &addressSize);
+#endif
     if (bytesRead < 0) {
       //##### HACK to work around bugs in Linux and Windows:
       int err = env.getErrno();
@@ -289,6 +341,7 @@
       }
       //##### END HACK
       socketErr(env, "recvfrom() error: ");
+      bytesRead = min(bytesRead, -err);
       break;
     }
   } while (0);
@@ -459,6 +512,83 @@
   return True;
 }
 
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+Boolean socketJoinGroup(UsageEnvironment& env, int socket, NetAddress const& groupAddress, u_int32_t nicIndex) {
+  if (!IsMulticastAddress(groupAddress)) return True; // ignore this case
+
+  int result;
+  if (groupAddress.GetAF() == AF_INET6) {
+    struct ipv6_mreq imr;
+    memcpy(&imr.ipv6mr_multiaddr, groupAddress.data(), sizeof(imr.ipv6mr_multiaddr));
+    imr.ipv6mr_interface = nicIndex;
+    result = setsockopt(socket, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP,
+	                   	  (const char*)&imr, sizeof(struct ipv6_mreq));
+    if (result < 0 || nicIndex != ReceivingInterfaceAddr) {
+      imr.ipv6mr_interface = ReceivingInterfaceAddr;
+      result = setsockopt(socket, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP,
+	                   	    (const char*)&imr, sizeof(struct ipv6_mreq));
+    }
+  } else if (groupAddress.GetAF() == AF_INET) {
+    struct ip_mreq imr;
+    memcpy(&imr.imr_multiaddr, groupAddress.data(), sizeof(imr.imr_multiaddr));
+    imr.imr_interface.s_addr = nicIndex ? htonl(nicIndex) : ReceivingInterfaceAddr;
+    result = setsockopt(socket, IPPROTO_IP, IP_ADD_MEMBERSHIP,
+	                   	  (const char*)&imr, sizeof(struct ip_mreq));
+  } else {
+    return False;
+  }
+
+  if (result < 0) {
+#if defined(__WIN32__) || defined(_WIN32)
+    if (env.getErrno() != 0) {
+      // That piece-of-shit toy operating system (Windows) sometimes lies
+      // about setsockopt() failing!
+#endif
+      socketErr(env, "setsockopt(IP_ADD_MEMBERSHIP) error: ");
+      return False;
+#if defined(__WIN32__) || defined(_WIN32)
+    }
+#endif
+  }
+
+  return True;
+}
+
+Boolean socketLeaveGroup(UsageEnvironment&, int socket, NetAddress const& groupAddress, u_int32_t nicIndex) {
+  if (!IsMulticastAddress(groupAddress)) return True; // ignore this case
+
+  int result;
+  if (groupAddress.GetAF() == AF_INET6) {
+    struct ipv6_mreq imr;
+    memcpy(&imr.ipv6mr_multiaddr, groupAddress.data(), sizeof(imr.ipv6mr_multiaddr));
+    imr.ipv6mr_interface = nicIndex;
+    result = setsockopt(socket, IPPROTO_IPV6, IPV6_DROP_MEMBERSHIP,
+	                   	  (const char*)&imr, sizeof(struct ipv6_mreq));
+    if (result < 0 || nicIndex != ReceivingInterfaceAddr) {
+      imr.ipv6mr_interface = ReceivingInterfaceAddr;
+      result = setsockopt(socket, IPPROTO_IPV6, IPV6_DROP_MEMBERSHIP,
+	                   	    (const char*)&imr, sizeof(struct ipv6_mreq));
+    }
+  } else if (groupAddress.GetAF() == AF_INET) {
+    struct ip_mreq imr;
+    memcpy(&imr.imr_multiaddr, groupAddress.data(), sizeof(imr.imr_multiaddr));
+    imr.imr_interface.s_addr = nicIndex ? htonl(nicIndex) : ReceivingInterfaceAddr;
+    result = setsockopt(socket, IPPROTO_IP, IP_DROP_MEMBERSHIP,
+	                   	  (const char*)&imr, sizeof(struct ip_mreq));
+  } else {
+    return False;
+  }
+
+  if (result < 0) {
+    return False;
+  }
+
+  return True;
+}
+#endif
+
+
 // The source-specific join/leave operations require special setsockopt()
 // commands, and a special structure (ip_mreq_source).  If the include files
 // didn't define these, we do so here:
@@ -527,12 +657,21 @@
 }
 
 static Boolean getSourcePort0(int socket, portNumBits& resultPortNum/*host order*/) {
+#ifdef LIVE_SUPPORT_IPV6
+  sockaddr_in6 test; test.sin6_port = 0;
+  SOCKLEN_T len = sizeof test;
+  if (getsockname(socket, (struct sockaddr*)&test, &len) < 0) return False;
+
+  resultPortNum = ntohs(test.sin6_port);
+  return True;
+#else
   sockaddr_in test; test.sin_port = 0;
   SOCKLEN_T len = sizeof test;
   if (getsockname(socket, (struct sockaddr*)&test, &len) < 0) return False;
 
   resultPortNum = ntohs(test.sin_port);
   return True;
+#endif
 }
 
 Boolean getSourcePort(UsageEnvironment& env, int socket, Port& port) {
@@ -567,7 +706,7 @@
   int sock = -1;
   struct in_addr testAddr;
 
-  if (ourAddress == 0) {
+  if ( 0 && (ourAddress == 0)) {
     // We need to find our source address
     struct sockaddr_in fromAddr;
     fromAddr.sin_addr.s_addr = 0;
@@ -701,7 +840,9 @@
 
 #if !defined(_WIN32_WCE)
   static char timeString[9]; // holds hh:mm:ss plus trailing '\0'
-  char const* ctimeResult = ctime((time_t*)&tvNow.tv_sec);
+  //char const* ctimeResult = ctime((time_t*)&tvNow.tv_sec);
+  time_t time_sec = tvNow.tv_sec;
+  char const* ctimeResult = ctime(&time_sec);
   char const* from = &ctimeResult[11];
   int i;
   for (i = 0; i < 8; ++i) {
diff -Naur original\live/groupsock/include/GroupEId.hh live/groupsock/include/GroupEId.hh
--- original\live/groupsock/include/GroupEId.hh	2009-11-27 13:25:55.000000000 +0300
+++ live/groupsock/include/GroupEId.hh	2014-11-30 14:36:26.015151700 +0300
@@ -66,6 +66,14 @@
       // used for a 'source-specific multicast' group
   GroupEId(); // used only as a temp constructor prior to initialization
 
+  // AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+  GroupEId(NetAddress const& groupAddrA,
+    portNumBits portNum, Scope const& scope,
+    unsigned numSuccessiveGroupAddrs = 1);
+  NetAddress groupAddressFull() const { return fGroupAddressA; }
+  NetAddress sourceFilterAddressFull() const { return fSourceFilterAddressA; }
+#endif
   struct in_addr const& groupAddress() const { return fGroupAddress; }
   struct in_addr const& sourceFilterAddress() const { return fSourceFilterAddress; }
 
@@ -81,6 +89,18 @@
   const Scope& scope() const { return fScope; }
 
 private:
+  // AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+  void init(NetAddress const& groupAddrA,
+    NetAddress const& sourceFilterAddrA,
+    portNumBits portNum,
+    Scope const& scope,
+    unsigned numSuccessiveGroupAddrs,
+    bool isSSM = false);
+
+  NetAddress fGroupAddressA;
+  NetAddress fSourceFilterAddressA;
+#endif
   void init(struct in_addr const& groupAddr,
 	    struct in_addr const& sourceFilterAddr,
 	    portNumBits portNum,
diff -Naur original\live/groupsock/include/Groupsock.hh live/groupsock/include/Groupsock.hh
--- original\live/groupsock/include/Groupsock.hh	2009-11-27 13:25:55.000000000 +0300
+++ live/groupsock/include/Groupsock.hh	2014-11-30 14:36:26.023152600 +0300
@@ -39,6 +39,11 @@
 class OutputSocket: public Socket {
 public:
   OutputSocket(UsageEnvironment& env);
+
+#ifdef LIVE_SUPPORT_IPV6
+  OutputSocket(UsageEnvironment& env, Port port, int AF);
+#endif
+
   virtual ~OutputSocket();
 
   Boolean write(netAddressBits address, Port port, u_int8_t ttl,
@@ -63,6 +68,12 @@
 public:
   destRecord(struct in_addr const& addr, Port const& port, u_int8_t ttl,
 	     destRecord* next);
+
+  // AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+  destRecord(NetAddress const& addr, Port const& port, u_int8_t ttl, destRecord* next);
+#endif
+
   virtual ~destRecord();
 
 public:
@@ -84,6 +95,13 @@
 	    struct in_addr const& sourceFilterAddr,
 	    Port port);
       // used for a 'source-specific multicast' group
+
+  // AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+  Groupsock(UsageEnvironment& env, NetAddress const& groupAddr, Port port, u_int8_t ttl, u_int32_t nicIndex = 0);
+  Groupsock(UsageEnvironment& env, NetAddress const& groupAddr, struct in_addr const& sourceFilterAddr, Port port);
+#endif
+
   virtual ~Groupsock();
 
   void changeDestinationParameters(struct in_addr const& newDestAddr,
@@ -95,9 +113,21 @@
       // number, at least, to be different from the source port.
       // (If a parameter is 0 (or ~0 for ttl), then no change made.)
 
+  // AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+  void changeDestinationParametersFull(NetAddress newDestAddr,
+    Port newDestPort, int newDestTTL);
+#endif
+
   // As a special case, we also allow multiple destinations (addresses & ports)
   // (This can be used to implement multi-unicast.)
   void addDestination(struct in_addr const& addr, Port const& port);
+
+  // AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+  void addDestination(NetAddress const& addr, Port const& port);
+#endif
+
   void removeDestination(struct in_addr const& addr, Port const& port);
   void removeAllDestinations();
 
@@ -120,7 +150,7 @@
 		 unsigned char* buffer, unsigned bufferSize,
 		 DirectedNetInterface* interfaceNotToFwdBackTo = NULL);
 
-  DirectedNetInterfaceSet& members() { return fMembers; }
+  DirectedNetInterfaceSet& members() { return *fMembers; }
 
   Boolean deleteIfNoMembers;
   Boolean isSlave; // for tunneling
@@ -152,7 +182,13 @@
   GroupEId fIncomingGroupEId;
   destRecord* fDests;
   u_int8_t fTTL;
-  DirectedNetInterfaceSet fMembers;
+  DirectedNetInterfaceSet *fMembers;
+  // AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+  u_int32_t fNIC;
+public:
+  static u_int32_t NIC;
+#endif
 };
 
 UsageEnvironment& operator<<(UsageEnvironment& s, const Groupsock& g);
diff -Naur original\live/groupsock/include/GroupsockHelper.hh live/groupsock/include/GroupsockHelper.hh
--- original\live/groupsock/include/GroupsockHelper.hh	2009-11-27 13:25:55.000000000 +0300
+++ live/groupsock/include/GroupsockHelper.hh	2014-11-30 14:36:26.032154500 +0300
@@ -21,15 +21,26 @@
 #ifndef _GROUPSOCK_HELPER_HH
 #define _GROUPSOCK_HELPER_HH
 
-#ifndef _NET_ADDRESS_HH
 #include "NetAddress.hh"
-#endif
 
 int setupDatagramSocket(UsageEnvironment& env,
-			Port port, Boolean setLoopback = True);
+			Port port, Boolean setLoopback = True
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+      , int AF = AF_INET
+#endif
+      );
 int setupStreamSocket(UsageEnvironment& env,
-		      Port port, Boolean makeNonBlocking = True);
+		      Port port, Boolean makeNonBlocking = True
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_TCP
+          , int AF = AF_INET
+#endif
+          );
 
+// AS fix for concurrect access to reading socket in TCP mode
+int blockUntilReadable(UsageEnvironment& env,
+			      int socket, struct timeval* timeout);
 int readSocket(UsageEnvironment& env,
 	       int socket, unsigned char* buffer, unsigned bufferSize,
 	       struct sockaddr_in& fromAddress,
@@ -65,6 +76,12 @@
 Boolean socketLeaveGroup(UsageEnvironment&, int socket,
 			 netAddressBits groupAddress);
 
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+Boolean socketJoinGroup(UsageEnvironment& env, int socket, NetAddress const& groupAddress, u_int32_t nicIndex);
+Boolean socketLeaveGroup(UsageEnvironment&, int socket, NetAddress const& groupAddress, u_int32_t nicIndex);
+#endif
+
 // source-specific multicast join/leave
 Boolean socketJoinGroupSSM(UsageEnvironment& env, int socket,
 			   netAddressBits groupAddress,
diff -Naur original\live/groupsock/include/NetAddress.hh live/groupsock/include/NetAddress.hh
--- original\live/groupsock/include/NetAddress.hh	2009-11-27 13:25:55.000000000 +0300
+++ live/groupsock/include/NetAddress.hh	2014-11-30 14:36:26.043156400 +0300
@@ -38,15 +38,39 @@
 // to allow for IPv6.
 typedef u_int32_t netAddressBits;
 
+// AS fix for IPv6
+#if defined(WINNT) || defined(_WINNT)
+#define LIVE_SUPPORT_IPV6
+#define LIVE_SUPPORT_IPV6_TCP
+#define LIVE_SUPPORT_IPV6_UDP
+#endif
+
 class NetAddress {
     public:
-	NetAddress(u_int8_t const* data,
+// AS fix for IPv6
+#ifndef LIVE_SUPPORT_IPV6
+	NetAddress(u_int8_t const* data,  // deprecated
 		   unsigned length = 4 /* default: 32 bits */);
 	NetAddress(unsigned length = 4); // sets address data to all-zeros
+#else
+  NetAddress(int AF = AF_INET);
+#endif
 	NetAddress(NetAddress const& orig);
 	NetAddress& operator=(NetAddress const& rightSide);
+  bool operator==(const NetAddress& addr) const;
 	virtual ~NetAddress();
 
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6
+  bool operator!=(const NetAddress& addr) const;
+  bool IsNotZero() const;
+  NetAddress(const ADDRINFO *AI);
+  int GetAF() const { return af;};
+  int GetSocket(int Type) const;
+  int Connect(int Socket, int Port) const;
+  int BindSocket(int Socket, int Port = 0) const;
+#endif
+
 	unsigned length() const { return fLength; }
 	u_int8_t const* data() const // always in network byte order
 		{ return fData; }
@@ -57,6 +81,9 @@
 
 	unsigned fLength;
 	u_int8_t* fData;
+#ifdef LIVE_SUPPORT_IPV6
+  int af;
+#endif
 };
 
 class NetAddressList {
@@ -142,5 +169,14 @@
 
 
 Boolean IsMulticastAddress(netAddressBits address);
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+Boolean IsMulticastAddress(NetAddress address);
+#endif
+
+// hack
+#ifdef LIVE_SUPPORT_IPV6
+extern int g_AF;
+#endif
 
 #endif
diff -Naur original\live/groupsock/include/NetInterface.hh live/groupsock/include/NetInterface.hh
--- original\live/groupsock/include/NetInterface.hh	2009-11-27 13:25:55.000000000 +0300
+++ live/groupsock/include/NetInterface.hh	2014-11-30 14:36:26.050157100 +0300
@@ -91,6 +91,9 @@
   Port port() const {
     return fPort;
   }
+#ifdef LIVE_SUPPORT_IPV6
+  int GetAF() const { return af;};
+#endif
 
   UsageEnvironment& env() const { return fEnv; }
 
@@ -100,13 +103,27 @@
   Socket(UsageEnvironment& env, Port port,
 	 Boolean setLoopback = True); // virtual base class
 
+#ifdef LIVE_SUPPORT_IPV6
+  Socket(UsageEnvironment& env, Port port, Boolean setLoopback, int AF); // virtual base class
+#endif
+
+#ifdef LIVE_SUPPORT_IPV6
+  Boolean changePort(Port newPort, int AF);
+#endif
   Boolean changePort(Port newPort); // will also cause socketNum() to change
 
+#ifdef LIVE_SUPPORT_IPV6
+  Boolean ChangeAF(int AF);
+#endif
+
 private:
   int fSocketNum;
   UsageEnvironment& fEnv;
   Port fPort;
   Boolean fSetLoopback;
+#ifdef LIVE_SUPPORT_IPV6
+  int af;
+#endif
 };
 
 UsageEnvironment& operator<<(UsageEnvironment& s, const Socket& sock);
diff -Naur original\live/groupsock/NetAddress.cpp live/groupsock/NetAddress.cpp
--- original\live/groupsock/NetAddress.cpp	2009-11-27 13:25:55.000000000 +0300
+++ live/groupsock/NetAddress.cpp	2014-11-30 14:36:26.061158900 +0300
@@ -31,6 +31,8 @@
 
 ////////// NetAddress //////////
 
+// AS fix for IPv6
+#ifndef LIVE_SUPPORT_IPV6
 NetAddress::NetAddress(u_int8_t const* data, unsigned length) {
   assign(data, length);
 }
@@ -46,18 +48,72 @@
   fLength = length;
 }
 
+// AS fix for IPv6
+#else //LIVE_SUPPORT_IPV6
+
+NetAddress::NetAddress(int AF)
+{
+  switch (AF)
+  {
+  case AF_INET:
+    af = AF_INET;
+    fData = new u_int8_t[fLength = 4];
+    break;
+  case AF_INET6:
+    af = AF_INET6;
+    fData = new u_int8_t[fLength = 16];
+    break;
+  default:
+  fData = NULL;
+    af = 0;
+  }
+  if (fData)
+  {
+    for (unsigned i = 0; i < fLength; ++i) 
+      fData[i] = 0;
+  }
+  else
+  {
+  fLength = 0;
+  }
+}
+// AS fix for IPv6
+#endif //LIVE_SUPPORT_IPV6
+
 NetAddress::NetAddress(NetAddress const& orig) {
   assign(orig.data(), orig.length());
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6
+  af = orig.af;
+#endif
 }
 
 NetAddress& NetAddress::operator=(NetAddress const& rightSide) {
   if (&rightSide != this) {
     clean();
     assign(rightSide.data(), rightSide.length());
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6
+    af = rightSide.af;
+#endif
   }
   return *this;
 }
 
+bool NetAddress::operator==(const NetAddress& addr) const
+{
+  bool equal = (length() == addr.length());
+#ifdef LIVE_SUPPORT_IPV6
+  equal &= (GetAF() == addr.GetAF());
+#endif
+  if (equal) {
+    for (unsigned i = 0; i < length(); ++i)	{
+      equal &= (data()[i] == addr.data()[i]);
+    }
+  }
+  return equal;
+}
+
 NetAddress::~NetAddress() {
   clean();
 }
@@ -80,6 +136,143 @@
 
 
 ////////// NetAddressList //////////
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6
+bool NetAddress::operator!=(const NetAddress& addr) const
+{
+  return !(*this == addr);
+}
+
+bool NetAddress::IsNotZero() const
+{
+  for (int i = 0; i < fLength; i++)
+  {
+    if (fData[i]) return true;
+  }
+  return false;
+}
+
+NetAddress::NetAddress(const ADDRINFO *AI)
+{
+  if (AI->ai_family == PF_INET)
+  {
+    assign((u_int8_t*)(AI->ai_addr->sa_data + 2), 4);
+    af = AF_INET;
+  }
+  if (AI->ai_family == PF_INET6)
+  {
+    assign((u_int8_t*)(AI->ai_addr->sa_data + 6), 16);
+    af = AF_INET6;
+  }
+}
+
+int NetAddress::GetSocket(int Type) const
+{
+  return socket(GetAF(), Type, 0);
+}
+
+#ifdef HAVE_SOCKADDR_LEN
+#define SET_SOCKADDR_SIN_LEN4(var) var.sin_len = sizeof var
+#else
+#define SET_SOCKADDR_SIN_LEN4(var)
+#endif
+
+#define MAKE_SOCKADDR_IN4(var,adr,prt) /*adr,prt must be in network order*/\
+struct sockaddr_in var;\
+  var.sin_family = AF_INET;\
+  memcpy(&var.sin_addr, (adr), 4);\
+  var.sin_port = (prt);\
+  SET_SOCKADDR_SIN_LEN4(var);
+
+
+#ifdef HAVE_SOCKADDR_LEN
+#define SET_SOCKADDR_SIN_LEN6(var) var.sin_len = sizeof var
+#else
+#define SET_SOCKADDR_SIN_LEN6(var)
+#endif
+
+#define MAKE_SOCKADDR_IN6(var, adr, prt) /*adr,prt must be in network order*/\
+struct sockaddr_in6 var;\
+  var.sin6_family = AF_INET6;\
+  var.sin6_flowinfo = 0; \
+  var.sin6_scope_id = 0; \
+  memcpy(&var.sin6_addr, (adr), 16);\
+  var.sin6_port = (prt);\
+  SET_SOCKADDR_SIN_LEN6(var);
+
+
+int NetAddress::Connect(int Socket, int Port) const
+{
+  if (af == AF_INET)
+  {
+    MAKE_SOCKADDR_IN4(sin, data(), Port);
+    return connect(Socket, (struct sockaddr*) &sin, sizeof(sin));
+  }
+  if (af == AF_INET6)
+  {
+    MAKE_SOCKADDR_IN6(sin, data(), Port);
+    return connect(Socket, (struct sockaddr*) &sin, sizeof(sin));
+  }
+  return -1;
+}
+
+int NetAddress::BindSocket(int Socket, int Port) const
+{
+  if (af == AF_INET)
+  {
+    MAKE_SOCKADDR_IN4(sin, data(), Port);
+    return bind(Socket, (struct sockaddr*) &sin, sizeof(sin));
+  }
+  if (af == AF_INET6)
+  {
+    MAKE_SOCKADDR_IN6(sin, data(), Port);
+    return bind(Socket, (struct sockaddr*) &sin, sizeof(sin));
+  }
+  return -1;
+}
+
+
+NetAddressList::NetAddressList(char const* hostname)
+: fNumAddresses(0), fAddressArray(NULL) {
+
+  ADDRINFO *AI, *AI2;
+  if (getaddrinfo(hostname, "", NULL, &AI) != 0) return;
+  fNumAddresses = 0;
+  AI2 = AI;
+  while (AI)
+  {
+    if ((AI->ai_family == PF_INET) || (AI->ai_family == PF_INET6))
+    fNumAddresses++;
+    AI = AI->ai_next;
+  };
+  if (!fNumAddresses)
+  {
+    freeaddrinfo(AI);
+    return;
+  }
+  fAddressArray = new NetAddress*[fNumAddresses];
+  if (fAddressArray == NULL)
+  {
+    freeaddrinfo(AI);
+    return;
+  }
+
+  AI = AI2;
+  int i = 0;
+  while (AI)
+  {
+    if ((AI->ai_family == PF_INET) || (AI->ai_family == PF_INET6))
+    {
+      fAddressArray[i] = new NetAddress(AI);
+      i++;
+    }
+    AI = AI->ai_next;
+  };
+  freeaddrinfo(AI);
+}
+
+// AS fix for IPv6
+#else //LIVE_SUPPORT_IPV6
 
 NetAddressList::NetAddressList(char const* hostname)
   : fNumAddresses(0), fAddressArray(NULL) {
@@ -138,6 +331,10 @@
     }
 }
 
+// AS fix for IPv6
+#endif //LIVE_SUPPORT_IPV6
+
+
 NetAddressList::NetAddressList(NetAddressList const& orig) {
   assign(orig.numAddresses(), orig.fAddressArray);
 }
@@ -264,3 +461,33 @@
   return addressInHostOrder >  0xE00000FF &&
          addressInHostOrder <= 0xEFFFFFFF;
 }
+
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+Boolean IsMulticastAddress(NetAddress address) {
+  if (address.GetAF() == AF_INET6) {
+    const u_int8_t dataLow = address.data()[1] & 0x0F;
+    return ((address.data()[0] == 0xFF) 
+            && (address.data()[1] > 0x0F) // ff00::/16 - ff0f::/16 Reserved
+            && ((dataLow == 1)            // ffx1::/16 Interface-local
+                 || (dataLow == 0x2)      // ffx2::/16 Link-local
+                 || (dataLow == 0x3)      // ffx3::/16 IPv4 local scope
+                 || (dataLow == 0x4)      // ffx4::/16 Admin-local
+                 || (dataLow == 0x5)      // ffx5::/16 Site-local
+                 || (dataLow == 0x6)      // ffx8::/16 Organization-local
+                 || (dataLow == 0xE)));   // ffxe::/16 Global scope
+  } else if (address.GetAF() == AF_INET) {
+    netAddressBits addressIPv4;
+    memcpy(&addressIPv4, address.data(), address.length());
+    netAddressBits addressInHostOrder = ntohl(addressIPv4);
+    return ((addressInHostOrder > 0xE00000FF) && (addressInHostOrder <= 0xEFFFFFFF));
+  } else {
+    return False;
+  }
+}
+#endif
+
+// hack
+#ifdef LIVE_SUPPORT_IPV6
+int g_AF = AF_INET;
+#endif
diff -Naur original\live/groupsock/NetInterface.cpp live/groupsock/NetInterface.cpp
--- original\live/groupsock/NetInterface.cpp	2009-11-27 13:25:55.000000000 +0300
+++ live/groupsock/NetInterface.cpp	2014-11-30 14:36:26.069159800 +0300
@@ -86,19 +86,52 @@
 
 Socket::Socket(UsageEnvironment& env, Port port, Boolean setLoopback)
   : fEnv(DefaultUsageEnvironment != NULL ? *DefaultUsageEnvironment : env), fPort(port), fSetLoopback(setLoopback) {
+
+#ifdef LIVE_SUPPORT_IPV6
+    // using hack with g_AF
+    fSocketNum = setupDatagramSocket(fEnv, port, setLoopback, g_AF);
+    af = g_AF;
+#else
   fSocketNum = setupDatagramSocket(fEnv, port, setLoopback);
+#endif
+}
+
+#ifdef LIVE_SUPPORT_IPV6
+Socket::Socket(UsageEnvironment& env, Port port, Boolean setLoopback, int AF)
+  : fEnv(DefaultUsageEnvironment != NULL ? *DefaultUsageEnvironment : env), 
+    fPort(port), fSetLoopback(setLoopback),
+    fSocketNum(setupDatagramSocket(fEnv, port, setLoopback, AF)), af(AF)
+{
 }
+#endif
 
 Socket::~Socket() {
   closeSocket(fSocketNum);
 }
 
+#ifdef LIVE_SUPPORT_IPV6
+Boolean Socket::changePort(Port newPort, int AF) {
+  closeSocket(fSocketNum);
+  fSocketNum = setupDatagramSocket(fEnv, newPort, fSetLoopback, AF);
+  return fSocketNum >= 0;
+}
+#endif
 Boolean Socket::changePort(Port newPort) {
   closeSocket(fSocketNum);
   fSocketNum = setupDatagramSocket(fEnv, newPort, fSetLoopback);
   return fSocketNum >= 0;
 }
 
+#ifdef LIVE_SUPPORT_IPV6
+Boolean Socket::ChangeAF(int AF) {
+  closeSocket(fSocketNum);
+  fSocketNum = setupDatagramSocket(fEnv, fPort, fSetLoopback, AF);
+  af = AF;
+  return fSocketNum >= 0;
+}
+#endif
+
+
 UsageEnvironment& operator<<(UsageEnvironment& s, const Socket& sock) {
 	return s << timestampString() << " Socket(" << sock.socketNum() << ")";
 }
diff -Naur original\live/liveMedia/Base64.cpp live/liveMedia/Base64.cpp
--- original\live/liveMedia/Base64.cpp	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/Base64.cpp	2014-11-30 14:36:26.080160800 +0300
@@ -111,3 +111,54 @@
   result[numResultBytes] = '\0';
   return result;
 }
+
+// AS Fix line-breaks in Base64 encoded messages
+char* base64Encode(char const* origSigned, unsigned origLength, bool lineBreaks) {
+  unsigned char const* orig = (unsigned char const*)origSigned; // in case any input bytes have the MSB set
+  if (orig == NULL) return NULL;
+
+  unsigned const numOrig24BitValues = origLength/3;
+  Boolean havePadding = origLength > numOrig24BitValues*3;
+  Boolean havePadding2 = origLength == numOrig24BitValues*3 + 2;
+  unsigned numResultBytes = 4*(numOrig24BitValues + havePadding);
+  // AS reserve bytes for line breaks
+  unsigned const maxLineLen = 64;
+  if (lineBreaks) {
+    numResultBytes += 2 * ((numResultBytes - 1) / maxLineLen);
+  }
+  char* result = new char[numResultBytes+1]; // allow for trailing '\0'
+ 
+  // Map each full group of 3 input bytes into 4 output base-64 characters:
+  unsigned i, line = 0, k = 0;
+  for (i = 0; i < numOrig24BitValues; ++i) {
+    result[k++] = base64Char[(orig[3*i]>>2)&0x3F];
+    result[k++] = base64Char[(((orig[3*i]&0x3)<<4) | (orig[3*i+1]>>4))&0x3F];
+    result[k++] = base64Char[((orig[3*i+1]<<2) | (orig[3*i+2]>>6))&0x3F];
+    result[k++] = base64Char[orig[3*i+2]&0x3F];
+    // AS insert line breaks for all lines except last
+    line += 4 ;
+    if (lineBreaks) {
+      if ((line == maxLineLen) && ((i < numOrig24BitValues - 1) || havePadding)) {
+        result[k++] = '\r';
+        result[k++] = '\n';
+        line = 0;
+      }
+    }
+  }
+ 
+  // Now, take padding into account.  (Note: i == numOrig24BitValues)
+  if (havePadding) {
+    result[k++] = base64Char[(orig[3*i]>>2)&0x3F];
+    if (havePadding2) {
+      result[k++] = base64Char[(((orig[3*i]&0x3)<<4) | (orig[3*i+1]>>4))&0x3F];
+      result[k++] = base64Char[(orig[3*i+1]<<2)&0x3F];
+    } else {
+      result[k++] = base64Char[((orig[3*i]&0x3)<<4)&0x3F];
+      result[k++] = '=';
+    }
+    result[k++] = '=';
+  }
+ 
+  result[numResultBytes] = '\0';
+  return result;
+}
diff -Naur original\live/liveMedia/BitVector.cpp live/liveMedia/BitVector.cpp
--- original\live/liveMedia/BitVector.cpp	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/BitVector.cpp	2014-11-30 14:36:26.089162300 +0300
@@ -14,7 +14,7 @@
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 **********/
 // "liveMedia"
-// Copyright (c) 1996-2009 Live Networks, Inc.  All rights reserved.
+// Copyright (c) 1996-2012 Live Networks, Inc.  All rights reserved.
 // Bit Vector data structure
 // Implementation
 
@@ -41,6 +41,8 @@
 #define MAX_LENGTH 32
 
 void BitVector::putBits(unsigned from, unsigned numBits) {
+  if (numBits == 0) return; 
+
   unsigned char tmpBuf[4];
   unsigned overflowingBits = 0;
 
@@ -63,7 +65,6 @@
   fCurBitIndex += numBits - overflowingBits;
 }
 
-
 void BitVector::put1Bit(unsigned bit) {
   // The following is equivalent to "putBits(..., 1)", except faster:
   if (fCurBitIndex >= fTotNumBits) { /* overflow */
@@ -79,8 +80,9 @@
   }
 }
 
-
 unsigned BitVector::getBits(unsigned numBits) {
+  if (numBits == 0) return 0;
+
   unsigned char tmpBuf[4];
   unsigned overflowingBits = 0;
 
@@ -125,10 +127,24 @@
   }
 }
 
+unsigned BitVector::get_expGolomb() {
+  unsigned numLeadingZeroBits = 0;
+  unsigned codeStart = 1;
+
+  while (get1Bit() == 0 && fCurBitIndex < fTotNumBits) {
+    ++numLeadingZeroBits;
+    codeStart *= 2;
+  }
+
+  return codeStart -1 + getBits(numLeadingZeroBits);
+}
+
 
 void shiftBits(unsigned char* toBasePtr, unsigned toBitOffset,
 	       unsigned char const* fromBasePtr, unsigned fromBitOffset,
 	       unsigned numBits) {
+  if (numBits == 0) return;
+
   /* Note that from and to may overlap, if from>to */
   unsigned char const* fromBytePtr = fromBasePtr + fromBitOffset/8;
   unsigned fromBitRem = fromBitOffset%8;
diff -Naur original\live/liveMedia/BitVector.hh live/liveMedia/BitVector.hh
--- original\live/liveMedia/BitVector.hh	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/BitVector.hh	2014-11-30 14:36:26.095162900 +0300
@@ -14,13 +14,17 @@
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 **********/
 // "liveMedia"
-// Copyright (c) 1996-2009 Live Networks, Inc.  All rights reserved.
+// Copyright (c) 1996-2012 Live Networks, Inc.  All rights reserved.
 // Bit Vector data structure
 // C++ header
 
 #ifndef _BIT_VECTOR_HH
 #define _BIT_VECTOR_HH
 
+#ifndef _BOOLEAN_HH
+#include "Boolean.hh"
+#endif
+
 class BitVector {
 public:
   BitVector(unsigned char* baseBytePtr,
@@ -36,6 +40,7 @@
 
   unsigned getBits(unsigned numBits); // "numBits" <= 32
   unsigned get1Bit();
+  Boolean get1BitBoolean() { return get1Bit() != 0; }
 
   void skipBits(unsigned numBits);
 
@@ -43,6 +48,9 @@
   unsigned totNumBits() const { return fTotNumBits; }
   unsigned numBitsRemaining() const { return fTotNumBits - fCurBitIndex; }
 
+  unsigned get_expGolomb();
+      // Returns the value of the next bits, assuming that they were encoded using an exponential-Golomb code of order 0
+
 private:
   unsigned char* fBaseBytePtr;
   unsigned fBaseBitOffset;
diff -Naur original\live/liveMedia/DigestAuthentication.cpp live/liveMedia/DigestAuthentication.cpp
--- original\live/liveMedia/DigestAuthentication.cpp	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/DigestAuthentication.cpp	2014-11-30 14:36:26.104164000 +0300
@@ -26,25 +26,59 @@
 #include <stdlib.h>
 #include <string.h>
 
+// AS Fix for qop
+#ifdef SUPPORT_QOP
+
+void CreateCNonce(char* CNonceVal) {
+  sprintf(CNonceVal, "%02x%02x%02x%02x", rand() & 0xff, rand() & 0xff, rand() & 0xff, rand() & 0xff);
+}
+
+
 Authenticator::Authenticator() {
-  assign(NULL, NULL, NULL, NULL, False);
+  assign(NULL, NULL, NULL, NULL, False, False);
+  fCNonceVal[0] = 0;
 }
 
 Authenticator::Authenticator(const Authenticator& orig) {
   assign(orig.realm(), orig.nonce(), orig.username(), orig.password(),
-	 orig.fPasswordIsMD5);
+	 orig.fPasswordIsMD5, orig.fQOP);
+  //memcpy(fCNonceVal, orig.fCNonceVal, sizeof(fCNonceVal));
+  CreateCNonce(fCNonceVal);
 }
 
 Authenticator& Authenticator::operator=(const Authenticator& rightSide) {
   if (&rightSide != this) {
     reset();
     assign(rightSide.realm(), rightSide.nonce(),
-	   rightSide.username(), rightSide.password(), rightSide.fPasswordIsMD5);
+	   rightSide.username(), rightSide.password(), rightSide.fPasswordIsMD5, rightSide.fQOP);
+    //memcpy(fCNonceVal, rightSide.fCNonceVal, sizeof(fCNonceVal));
+    CreateCNonce(fCNonceVal);
   }
 
   return *this;
 }
 
+#else // SUPPORT_QOP
+
+Authenticator::Authenticator() {
+  assign(NULL, NULL, NULL, NULL, False);
+}
+
+Authenticator::Authenticator(const Authenticator& orig) {
+  assign(orig.realm(), orig.nonce(), orig.username(), orig.password(),
+	 orig.fPasswordIsMD5);
+}
+
+Authenticator& Authenticator::operator=(const Authenticator& rightSide) {
+  if (&rightSide != this) {
+    reset();
+    assign(rightSide.realm(), rightSide.nonce(),
+	   rightSide.username(), rightSide.password(), rightSide.fPasswordIsMD5);
+}
+
+#endif // SUPPORT_QOP
+
+  
 Authenticator::~Authenticator() {
   reset();
 }
@@ -91,6 +125,21 @@
   //    md5(md5(<username>:<realm>:<password>):<nonce>:md5(<cmd>:<url>))
   // or, if "fPasswordIsMD5" is True:
   //    md5(<password>:<nonce>:md5(<cmd>:<url>))
+               /*
+
+               HA1 = MD5( "Mufasa:testrealm@host.com:Circle Of Life" )
+               = 939e7578ed9e3c518a452acee763bce9
+
+               HA2 = MD5( "GET:/dir/index.html" )
+               = 39aff3a2bab6126f332b942af96d3366
+
+               Response = MD5( "939e7578ed9e3c518a452acee763bce9:\
+               dcd98b7102dd2f0e8b11d0f600bfb0c093:\
+               00000001:0a4f113b:auth:\
+               39aff3a2bab6126f332b942af96d3366" )
+               = 6629fae49393a05397450978507c4ef1
+
+               */
   char ha1Buf[33];
   if (fPasswordIsMD5) {
     strncpy(ha1Buf, password(), 32);
@@ -111,6 +160,36 @@
   our_MD5Data(ha2Data, ha2DataLen, ha2Buf);
   delete[] ha2Data;
 
+// AS Fix for qop
+#ifdef SUPPORT_QOP
+
+  char const* result;
+  if (qop())
+  {
+    unsigned const digestDataLen
+      = 32 + 1 + strlen(nonce()) + 1 + 32 + 23;
+
+    unsigned char* digestData = new unsigned char[digestDataLen+1];
+    sprintf((char*)digestData, "%s:%s:00000001:%s:auth:%s",
+      ha1Buf, nonce(), cnonce(), ha2Buf);
+    result = our_MD5Data(digestData, digestDataLen, NULL);
+    delete[] digestData;
+
+  }
+  else
+  {
+    unsigned const digestDataLen
+      = 32 + 1 + strlen(nonce()) + 1 + 32;
+    unsigned char* digestData = new unsigned char[digestDataLen+1];
+    sprintf((char*)digestData, "%s:%s:%s",
+      ha1Buf, nonce(), ha2Buf);
+    result = our_MD5Data(digestData, digestDataLen, NULL);
+    delete[] digestData;
+  }
+  return result;
+
+// AS Fix for qop
+#else // SUPPORT_QOP
   unsigned const digestDataLen
     = 32 + 1 + strlen(nonce()) + 1 + 32;
   unsigned char* digestData = new unsigned char[digestDataLen+1];
@@ -119,7 +198,19 @@
   char const* result = our_MD5Data(digestData, digestDataLen, NULL);
   delete[] digestData;
   return result;
+// AS Fix for qop
+#endif // SUPPORT_QOP
+}
+
+// AS Fix for qop
+#ifdef SUPPORT_QOP
+void Authenticator::setQOP()
+{
+  fQOP = True;
+  CreateCNonce(fCNonceVal);
 }
+#endif // SUPPORT_QOP
+
 
 void Authenticator::reclaimDigestResponse(char const* responseStr) const {
   free((char*)responseStr); // NOT delete, because it was malloc-allocated
@@ -134,6 +225,7 @@
   delete[] fUsername; fUsername = NULL;
   delete[] fPassword; fPassword = NULL;
   fPasswordIsMD5 = False;
+  fQOP = False;
 }
 
 void Authenticator::assignRealmAndNonce(char const* realm, char const* nonce) {
@@ -149,9 +241,23 @@
   fPasswordIsMD5 = passwordIsMD5;
 }
 
+// AS Fix for qop
+#ifdef SUPPORT_QOP
+
+void Authenticator::assign(char const* realm, char const* nonce,
+			   char const* username, char const* password,
+			   Boolean passwordIsMD5, Boolean QOP) {
+  assignRealmAndNonce(realm, nonce);
+  assignUsernameAndPassword(username, password, passwordIsMD5);
+  fQOP = QOP;
+}
+
+#else // SUPPORT_QOP
 void Authenticator::assign(char const* realm, char const* nonce,
 			   char const* username, char const* password,
 			   Boolean passwordIsMD5) {
   assignRealmAndNonce(realm, nonce);
   assignUsernameAndPassword(username, password, passwordIsMD5);
+  fQOP = False;
 }
+#endif // SUPPORT_QOP
\ No newline at end of file
diff -Naur original\live/liveMedia/FramedSource.cpp live/liveMedia/FramedSource.cpp
--- original\live/liveMedia/FramedSource.cpp	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/FramedSource.cpp	2014-11-30 14:36:26.113165900 +0300
@@ -27,7 +27,9 @@
   : MediaSource(env),
     fAfterGettingFunc(NULL), fAfterGettingClientData(NULL),
     fOnCloseFunc(NULL), fOnCloseClientData(NULL),
-    fIsCurrentlyAwaitingData(False) {
+    fIsCurrentlyAwaitingData(False),
+    // AS Fix output frame width/height
+    fFrameWidth(0), fFrameHeight(0) {
   fPresentationTime.tv_sec = fPresentationTime.tv_usec = 0; // initially
 }
 
diff -Naur original\live/liveMedia/include/Base64.hh live/liveMedia/include/Base64.hh
--- original\live/liveMedia/include/Base64.hh	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/include/Base64.hh	2014-11-30 14:36:26.120166600 +0300
@@ -34,4 +34,7 @@
     // returns a 0-terminated string that
     // the caller is responsible for delete[]ing.
 
+// AS version with linebreaks insertion ability
+char* base64Encode(char const* origSigned, unsigned origLength, bool lineBreaks);
+
 #endif
diff -Naur original\live/liveMedia/include/DigestAuthentication.hh live/liveMedia/include/DigestAuthentication.hh
--- original\live/liveMedia/include/DigestAuthentication.hh	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/include/DigestAuthentication.hh	2014-11-30 14:36:26.126167200 +0300
@@ -25,6 +25,9 @@
 #include <Boolean.hh>
 #endif
 
+// AS Fix for qop
+#define SUPPORT_QOP
+
 // A class used for digest authentication.
 // The "realm", and "nonce" fields are supplied by the server
 // (in a "401 Unauthorized" response).
@@ -46,6 +49,13 @@
       // If "passwordIsMD5" is True, then "password" is actually the value computed
       // by md5(<username>:<realm>:<actual-password>)
 
+// AS Fix for qop
+#ifdef SUPPORT_QOP
+  void setQOP();
+  Boolean qop() const { return fQOP; }
+  char const* cnonce() const { return fCNonceVal; }
+#endif // SUPPORT_QOP
+
   char const* realm() const { return fRealm; }
   char const* nonce() const { return fNonce; }
   char const* username() const { return fUsername; }
@@ -60,13 +70,23 @@
   void assignRealmAndNonce(char const* realm, char const* nonce);
   void assignUsernameAndPassword(char const* username, char const* password,
 				 Boolean passwordIsMD5);
+  // AS Fix for qop
+#ifdef SUPPORT_QOP
+  void assign(char const* realm, char const* nonce,
+    char const* username, char const* password, Boolean passwordIsMD5, Boolean QOP);
+#else // SUPPORT_QOP
   void assign(char const* realm, char const* nonce,
 	      char const* username, char const* password, Boolean passwordIsMD5);
-
+#endif // SUPPORT_QOP
 private:
   char* fRealm; char* fNonce;
   char* fUsername; char* fPassword;
   Boolean fPasswordIsMD5;
+  // AS Fix for qop
+#ifdef SUPPORT_QOP
+  Boolean fQOP;
+  char fCNonceVal[10];
+#endif // SUPPORT_QOP
 };
 
 #endif
diff -Naur original\live/liveMedia/include/FramedSource.hh live/liveMedia/include/FramedSource.hh
--- original\live/liveMedia/include/FramedSource.hh	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/include/FramedSource.hh	2014-11-30 14:36:26.132168600 +0300
@@ -78,6 +78,12 @@
   struct timeval fPresentationTime; // out
   unsigned fDurationInMicroseconds; // out
 
+// AS Fix output frame width/height
+public:
+  unsigned fFrameWidth;
+  unsigned fFrameHeight;
+  bool IsFrameDimensionsParsed() { return (fFrameWidth > 0 && fFrameHeight > 0); }
+
 private:
   // redefined virtual functions:
   virtual Boolean isFramedSource() const;
diff -Naur original\live/liveMedia/include/JPEGVideoRTPSource.hh live/liveMedia/include/JPEGVideoRTPSource.hh
--- original\live/liveMedia/include/JPEGVideoRTPSource.hh	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/include/JPEGVideoRTPSource.hh	2014-11-30 14:36:26.140169100 +0300
@@ -38,6 +38,11 @@
 protected:
   virtual ~JPEGVideoRTPSource();
 
+  // AS Fix for additional headers in JPEG
+#ifdef ADD_3MP_SUPPORT
+  virtual Boolean processExtData(BufferedPacket* packet, unsigned extHdr);
+#endif
+
 private:
   JPEGVideoRTPSource(UsageEnvironment& env, Groupsock* RTPgs,
 		     unsigned char rtpPayloadFormat,
diff -Naur original\live/liveMedia/include/MediaSession.hh live/liveMedia/include/MediaSession.hh
--- original\live/liveMedia/include/MediaSession.hh	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/include/MediaSession.hh	2014-11-30 14:36:26.151171800 +0300
@@ -158,7 +158,9 @@
   double& _playStartTime() { return fPlayStartTime; }
   double& _playEndTime() { return fPlayEndTime; }
 
-  Boolean initiate(int useSpecialRTPoffset = -1);
+  Boolean initiate(int useSpecialRTPoffset = -1,
+                   // AS callback for RTP packet extensions
+                   RTPSource::RtpExtHdrCallback_t rtpExtHdrCallback = NULL, void *pPriv = NULL);
       // Creates a "RTPSource" for this subsession. (Has no effect if it's
       // already been created.)  Returns True iff this succeeds.
   void deInitiate(); // Destroys any previously created RTPSource
@@ -205,6 +207,11 @@
       // Uses "fConnectionEndpointName" and "serverPortNum" to set
       // the destination address and port of the RTP and RTCP objects.
       // This is typically called by RTSP clients after doing "SETUP".
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+  NetAddress connectionEndpointAddressFull() const;
+  void setDestinationsFull(NetAddress defaultDestAddress);
+#endif
 
   // Public fields that external callers can use to keep state.
   // (They are responsible for all storage management on these fields)
@@ -229,6 +236,8 @@
   // Also, for this function to work properly, the RTP stream's presentation times must (eventually) be
   // synchronized via RTCP.
 
+  Boolean IsValidMulticastEndpointAddress() const;
+
 #ifdef SUPPORT_REAL_RTSP
   // Attributes specific to RealNetworks streams:
   unsigned fRealMaxBitRate, fRealAvgBitRate, fRealMaxPacketSize, fRealAvgPacketSize, fRealPreroll;
@@ -257,6 +266,8 @@
   Boolean parseSDPAttribute_source_filter(char const* sdpLine);
   Boolean parseSDPAttribute_x_dimensions(char const* sdpLine);
   Boolean parseSDPAttribute_framerate(char const* sdpLine);
+  // AS Fix: field from RFC6064
+  Boolean parseSDPAttribute_framesize(char const* sdpLine);
 
 protected:
   // Linkage fields:
diff -Naur original\live/liveMedia/include/MultiFramedRTPSource.hh live/liveMedia/include/MultiFramedRTPSource.hh
--- original\live/liveMedia/include/MultiFramedRTPSource.hh	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/include/MultiFramedRTPSource.hh	2014-11-30 14:36:26.159171900 +0300
@@ -26,6 +26,9 @@
 #include "RTPSource.hh"
 #endif
 
+// AS Fix for additional headers in JPEG
+#define ADD_3MP_SUPPORT
+
 class BufferedPacket; // forward
 class BufferedPacketFactory; // forward
 
@@ -38,6 +41,10 @@
       // virtual base class
   virtual ~MultiFramedRTPSource();
 
+  // AS Fix for additional headers in JPEG
+#ifdef ADD_3MP_SUPPORT
+  virtual Boolean processExtData(BufferedPacket* packet, unsigned extHdr) { return False; };
+#endif
   virtual Boolean processSpecialHeader(BufferedPacket* packet,
 				       unsigned& resultSpecialHeaderSize);
       // Subclasses redefine this to handle any special, payload format
diff -Naur original\live/liveMedia/include/RTCP.hh live/liveMedia/include/RTCP.hh
--- original\live/liveMedia/include/RTCP.hh	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/include/RTCP.hh	2014-11-30 14:36:26.170174600 +0300
@@ -81,8 +81,8 @@
       // and a general "RR" handler function is set, then both will be called.)
 
   Groupsock* RTCPgs() const { return fRTCPInterface.gs(); }
-
-  void setStreamSocket(int sockNum, unsigned char streamChannelId);
+// AS fix for concurrect access to reading socket in TCP mode
+  void setStreamSocket(int sockNum, unsigned char streamChannelId, CRITICAL_SECTION *pCriticalSection = 0);
   void addStreamSocket(int sockNum, unsigned char streamChannelId);
   void removeStreamSocket(int sockNum, unsigned char streamChannelId) {
     fRTCPInterface.removeStreamSocket(sockNum, streamChannelId);
@@ -103,6 +103,10 @@
       // called only by createNew()
   virtual ~RTCPInstance();
 
+#ifdef DEBUG
+  int fprintf(FILE *Tmp, const char *Format, ...);
+#endif
+
 private:
   // redefined virtual functions:
   virtual Boolean isRTCPInstance() const;
diff -Naur original\live/liveMedia/include/RTPInterface.hh live/liveMedia/include/RTPInterface.hh
--- original\live/liveMedia/include/RTPInterface.hh	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/include/RTPInterface.hh	2014-11-30 14:36:26.180175800 +0300
@@ -54,7 +54,8 @@
 
   Groupsock* gs() const { return fGS; }
 
-  void setStreamSocket(int sockNum, unsigned char streamChannelId);
+// AS fix for concurrect access to reading socket in TCP mode
+  void setStreamSocket(int sockNum, unsigned char streamChannelId, CRITICAL_SECTION *pCriticalSection = 0);
   void addStreamSocket(int sockNum, unsigned char streamChannelId);
   void removeStreamSocket(int sockNum, unsigned char streamChannelId);
 
@@ -92,6 +93,8 @@
 
   AuxHandlerFunc* fAuxReadHandlerFunc;
   void* fAuxReadHandlerClientData;
+// AS fix for concurrect access to reading socket in TCP mode
+  CRITICAL_SECTION *pCriticalSection;
 };
 
 #endif
diff -Naur original\live/liveMedia/include/RTPSource.hh live/liveMedia/include/RTPSource.hh
--- original\live/liveMedia/include/RTPSource.hh	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/include/RTPSource.hh	2014-11-30 14:36:26.188175400 +0300
@@ -59,9 +59,10 @@
   u_int32_t lastReceivedSSRC() const { return fLastReceivedSSRC; }
   // Note: This is the SSRC in the most recently received RTP packet; not *our* SSRC
 
-  void setStreamSocket(int sockNum, unsigned char streamChannelId) {
+// AS fix for concurrect access to reading socket in TCP mode
+  void setStreamSocket(int sockNum, unsigned char streamChannelId, CRITICAL_SECTION *pCriticalSection = 0) {
     // hack to allow sending RTP over TCP (RFC 2236, section 10.12)
-    fRTPInterface.setStreamSocket(sockNum, streamChannelId);
+    fRTPInterface.setStreamSocket(sockNum, streamChannelId, pCriticalSection);
   }
 
   void setAuxilliaryReadHandler(AuxHandlerFunc* handlerFunc,
@@ -76,6 +77,13 @@
   u_int16_t curPacketRTPSeqNum() const { return fCurPacketRTPSeqNum; }
   u_int32_t curPacketRTPTimestamp() const { return fCurPacketRTPTimestamp; }
 
+  // This is used to set a callback to retrieve the RTP Header Extension data
+  typedef void (*RtpExtHdrCallback_t)(u_int16_t profile, u_int16_t seq, u_int16_t len, u_int8_t* pHdrData, void* pPriv);
+  void setRtpExtHdrCallback(RtpExtHdrCallback_t callback, void* pPriv) { fRtpExtHdrCallback = callback; fRtpExtHdrCallbackPrivData = pPriv; } 
+  // AS Fix callback for checking payload type
+  typedef bool (*CheckPldTypeCallback_t)(u_int8_t type, unsigned char *packetData, unsigned int packetSize, void* pPriv);
+  void setCheckPldTypeCallback(CheckPldTypeCallback_t callback, void* pPriv) { fCheckPldTypeCallback = callback; fCheckPldTypeCallbackPrivData = pPriv; } 
+
 protected:
   RTPSource(UsageEnvironment& env, Groupsock* RTPgs,
 	    unsigned char rtpPayloadFormat, u_int32_t rtpTimestampFrequency);
@@ -89,6 +97,11 @@
   Boolean fCurPacketMarkerBit;
   Boolean fCurPacketHasBeenSynchronizedUsingRTCP;
   u_int32_t fLastReceivedSSRC;
+  RtpExtHdrCallback_t fRtpExtHdrCallback;
+  void*               fRtpExtHdrCallbackPrivData;
+  // AS Fix callback for checking payload type
+  CheckPldTypeCallback_t   fCheckPldTypeCallback;
+  void*               fCheckPldTypeCallbackPrivData;
 
 private:
   // redefined virtual functions:
diff -Naur original\live/liveMedia/include/RTSPClient.hh live/liveMedia/include/RTSPClient.hh
--- original\live/liveMedia/include/RTSPClient.hh	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/include/RTSPClient.hh	2014-11-30 14:36:26.197177400 +0300
@@ -150,10 +150,33 @@
 
   unsigned sessionTimeoutParameter() const { return fSessionTimeoutParameter; }
 
+// AS Fix support for line-breaks in Base64
+  void setBase64LineBreaks(bool value) { fBase64LineBreaks = value; }
+// AS Fix custom string to add to RTSP command
+  void setCustomFields(char *value) { fCustomFields = value; }
+// AS Fix switch for read all from socket instead of by 1 byte
+  void setSocketReadAllMode(bool value) { fSocketReadAllMode = value; }
+  int readSocketByte(UsageEnvironment& env,
+        int socket, unsigned char* buffer, unsigned bufferSize,
+        struct sockaddr_in& fromAddress, struct timeval* timeout = NULL);
+// AS Fix CSeq getter
+  static unsigned CSeq() { return fCSeq; }
+
 #ifdef SUPPORT_REAL_RTSP
   Boolean usingRealNetworksChallengeResponse() const { return fRealChallengeStr != NULL; }
 #endif
 
+// AS Fix access to commands response
+  const char* ResponseBuffer() const { return fResponseBuffer2; };
+  unsigned ResponseBufferSize() { return fResponseBufferSize; };
+// AS Fix destination setting for SETUP command
+  void setSetupDestination (char *value) { fSetupDestination = value; }
+
+// AS Fix access to commands request and response
+  const char* GetRtspRequestBuffer() const { return fRtspRequestBuffer; };
+  const char* GetRtspResponseBuffer() const { return fRtspResponseBuffer; };
+  //unsigned RequestBufferSize() { return fRequestBufferSize; };
+
 protected:
   RTSPClient(UsageEnvironment& env, int verbosityLevel,
 	     char const* applicationName, portNumBits tunnelOverHTTPPortNum);
@@ -210,7 +233,13 @@
   char* fUserAgentHeaderStr;
       unsigned fUserAgentHeaderStrSize;
   int fInputSocketNum, fOutputSocketNum;
-  unsigned fServerAddress;
+
+// AS fix for IPv6
+  unsigned fServerAddress; // deprecated
+#ifdef LIVE_SUPPORT_IPV6
+  NetAddress fServerAddressFull;
+#endif
+
   static unsigned fCSeq; // sequence number, used in consecutive requests
       // Note: it's static, to ensure that it differs if more than one
       // connection is made to the same server, using the same URL.
@@ -228,6 +257,7 @@
   // 0: OK; 1: connection failed; 2: stream unavailable
   char* fResponseBuffer;
   unsigned fResponseBufferSize;
+  //unsigned fRequestBufferSize;
 
   // The following fields are used to implement the non-standard Kasenna protocol:
   Boolean fServerIsKasenna;
@@ -235,6 +265,25 @@
 
   // The following is used to deal with Microsoft servers' non-standard use of RTSP:
   Boolean fServerIsMicrosoft;
+
+// AS Fix support for line-breaks in Base64
+  bool fBase64LineBreaks;
+// AS Fix custom string to add to RTSP command
+  char *fCustomFields;
+// AS Fix switch for read all from socket instead of by 1 byte
+  bool fSocketReadAllMode;
+  char *fResponseBuffer2;
+// AS Fix destination setting for SETUP command
+  char *fSetupDestination;
+
+// AS fix: add synchronization to avoid bugs with using 
+// function getResponse1 in 2 threads simultaneously 
+  CRITICAL_SECTION fCriticalSection; 
+
+// AS fix: buffer for RTSP request and response 
+  char *fRtspRequestBuffer;
+  char *fRtspResponseBuffer;
+
 };
 
 #endif
diff -Naur original\live/liveMedia/JPEGVideoRTPSource.cpp live/liveMedia/JPEGVideoRTPSource.cpp
--- original\live/liveMedia/JPEGVideoRTPSource.cpp	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/JPEGVideoRTPSource.cpp	2014-12-03 14:00:07.049036800 +0300
@@ -173,6 +173,10 @@
   unsigned qtlen_half = qtlen/2; // in case qtlen is odd; shouldn't happen
   return 495 + qtlen_half*2 + (dri > 0 ? 6 : 0);
 }
+// AS fix for JPEG aspect ratio header
+extern int Un, xD, yD;
+// AS fix for JPEG size header
+extern int xSize, ySize;
 
 static void createJPEGHeader(unsigned char* buf, unsigned type,
 			     unsigned w, unsigned h,
@@ -180,7 +184,15 @@
 			     unsigned dri) {
   unsigned char *ptr = buf;
   unsigned numQtables = qtlen > 64 ? 2 : 1;
-
+  // AS fix for JPEG size header
+  if (xSize && ySize)
+  {
+    char B[200];
+    sprintf(B, "SZ[%x, %x]\n", xSize, ySize);
+    OutputDebugStringA(B);
+    //w = xSize;
+    //h = ySize;
+  }
   // MARKER_SOI:
   *ptr++ = 0xFF; *ptr++ = MARKER_SOI;
 
@@ -189,9 +201,19 @@
   *ptr++ = 0x00; *ptr++ = 0x10; // size of chunk
   *ptr++ = 'J'; *ptr++ = 'F'; *ptr++ = 'I'; *ptr++ = 'F'; *ptr++ = 0x00;
   *ptr++ = 0x01; *ptr++ = 0x01; // JFIF format version (1.1)
+  // AS fix for JPEG aspect ratio header
+  if (xD && yD)
+  {
+    *ptr++ = Un; 
+    *ptr++ = 0x00; *ptr++ = yD; // Horizontal pixel aspect ratio
+    *ptr++ = 0x00; *ptr++ = xD; // Vertical pixel aspect ratio
+  }
+  else
+  {
   *ptr++ = 0x00; // no units
   *ptr++ = 0x00; *ptr++ = 0x01; // Horizontal pixel aspect ratio
   *ptr++ = 0x00; *ptr++ = 0x01; // Vertical pixel aspect ratio
+  }
   *ptr++ = 0x00; *ptr++ = 0x00; // no thumbnail
 
   // MARKER_DRI:
@@ -307,6 +329,412 @@
   }
 }
 
+// AS Fix for additional headers in JPEG
+#ifdef ADD_3MP_SUPPORT
+struct jpegExtData {
+  unsigned char headers[10][4 * 256];
+  int Ofs;
+  int Size;
+  bool AllProcessed;
+  bool UseExtAsPayload;
+  
+  int LastSize;
+  unsigned char unparsed[3];
+  unsigned char *lastBuffer;
+
+  unsigned computeJPEGHeaderSize(unsigned qtlen, unsigned dri);
+  void createJPEGHeader(unsigned char* buf, unsigned type,
+    unsigned w, unsigned h,
+    unsigned char const* qtables, unsigned qtlen,
+    unsigned dri);
+};
+
+#define CALC_HEADER_SIZE(buffer) (2 + ((buffer[2] << 8) | buffer[3]))
+
+unsigned jpegExtData::
+computeJPEGHeaderSize(unsigned qtlen, unsigned dri) {
+
+
+  // check integrity
+  // SOF - DQT
+  if (headers[2][0]) { 
+    if (!headers[2][12] && !headers[2][15]) { // only one table need
+      memset(headers[9], 0, sizeof(headers[9]));
+    } else {
+      if (!headers[9][0]) { // no second table - SOF invalid, DQT1 invalid
+        //memset(headers[2], 0, sizeof(headers[2]));
+        //memset(headers[8], 0, sizeof(headers[8]));
+      }
+    }
+  } else {
+    // use default QT
+    memset(headers[8], 0, sizeof(headers[8]) * 2);
+  };
+  
+  // SOS - DHT
+  if (headers[3][0]) { 
+  } else {
+    // use default HT
+    memset(headers[4], 0, sizeof(headers[4]) * 4);
+  };
+
+  // calculation
+  int len = 2; // SOI
+
+  // 0xe0: // APP0-JFIF
+  if (headers[0][0]) { 
+    len += CALC_HEADER_SIZE(headers[0]);
+  } else {
+    len += 18;
+  };
+
+  // 0xdd: // DRI
+  if (headers[1][0]) { 
+    len += CALC_HEADER_SIZE(headers[1]);
+  } else {
+    if (dri > 0) len += 6;
+  };
+
+  // 0xdb: // DQT
+  if (headers[8][0] || headers[9][0]) { 
+    if (headers[8][0]) { 
+      len += CALC_HEADER_SIZE(headers[8]);
+    }
+    if (headers[9][0]) { 
+      len += CALC_HEADER_SIZE(headers[9]);
+    }
+  } else {
+    // use default QT
+    len += 5 + qtlen;
+    if (qtlen > 64) len += 5;
+  };
+
+
+  // 0xc0: // SOF0
+  if (headers[2][0]) { 
+    len += CALC_HEADER_SIZE(headers[2]);
+  } else {
+    // use default QT
+    len += 19;
+  };
+
+  // 0xc4: // DHT
+  if (headers[4][0]) { 
+    len += CALC_HEADER_SIZE(headers[4]);
+  } else if (!headers[3][0]) {
+    // use default HT 
+    len += 5 + sizeof(lum_dc_codelens) + sizeof(lum_dc_symbols);
+  };
+  // 0xc4: // DHT
+  if (headers[6][0]) { 
+    len += CALC_HEADER_SIZE(headers[6]);
+  } else if (!headers[3][0]) {
+    // use default HT 
+    len += 5 + sizeof(lum_ac_codelens) + sizeof(lum_ac_symbols);
+  };
+  // 0xc4: // DHT
+  if (headers[5][0]) { 
+    len += CALC_HEADER_SIZE(headers[5]);
+  } else if (!headers[3][0]) {
+    // use default HT 
+    len += 5 + sizeof(chm_dc_codelens) + sizeof(chm_dc_symbols);
+  };
+  // 0xc4: // DHT
+  if (headers[7][0]) { 
+    len += CALC_HEADER_SIZE(headers[7]);
+  } else if (!headers[3][0]) {
+    // use default HT 
+    len += 5 + sizeof(chm_ac_codelens) + sizeof(chm_ac_symbols);
+  };
+
+  // 0xda: // SOS
+  if (headers[3][0]) { 
+    len += CALC_HEADER_SIZE(headers[3]);
+  } else {
+    // use default HT
+    len += 14;
+  };
+
+  return len;
+}
+
+void jpegExtData::
+createJPEGHeader(unsigned char* buf, unsigned type,
+                      unsigned w, unsigned h,
+                      unsigned char const* qtables, unsigned qtlen,
+                      unsigned dri) {
+
+  unsigned char *ptr = buf;
+  unsigned numQtables = qtlen > 64 ? 2 : 1;
+  unsigned int len;
+
+  // MARKER_SOI:
+  *ptr++ = 0xFF; *ptr++ = MARKER_SOI;
+
+  if (headers[0][0]) { 
+    len = CALC_HEADER_SIZE(headers[0]);
+    memcpy(ptr, headers[0], len);
+    ptr += len;
+  } else {
+  // MARKER_APP_FIRST:
+  *ptr++ = 0xFF; *ptr++ = MARKER_APP_FIRST;
+  *ptr++ = 0x00; *ptr++ = 0x10; // size of chunk
+  *ptr++ = 'J'; *ptr++ = 'F'; *ptr++ = 'I'; *ptr++ = 'F'; *ptr++ = 0x00;
+  *ptr++ = 0x01; *ptr++ = 0x01; // JFIF format version (1.1)
+  *ptr++ = 0x00; // no units
+  *ptr++ = 0x00; *ptr++ = 0x01; // Horizontal pixel aspect ratio
+  *ptr++ = 0x00; *ptr++ = 0x01; // Vertical pixel aspect ratio
+  *ptr++ = 0x00; *ptr++ = 0x00; // no thumbnail
+  };
+
+  // 0xdd: // DRI
+  if (headers[1][0]) { 
+    len = CALC_HEADER_SIZE(headers[1]);
+    memcpy(ptr, headers[1], len);
+    ptr += len;
+  } else {
+  // MARKER_DRI:
+  if (dri > 0) {
+    *ptr++ = 0xFF; *ptr++ = MARKER_DRI;
+    *ptr++ = 0x00; *ptr++ = 0x04; // size of chunk
+    *ptr++ = (BYTE)(dri >> 8); *ptr++ = (BYTE)(dri); // restart interval
+  }
+  };
+
+  // 0xc0: // SOF0
+  if (headers[2][0]) { 
+    len = CALC_HEADER_SIZE(headers[8]);
+    memcpy(ptr, headers[8], len);
+    ptr += len;
+    if (headers[9][0]) {
+      len = CALC_HEADER_SIZE(headers[9]);
+      memcpy(ptr, headers[9], len);
+      ptr += len;
+    }
+    len = CALC_HEADER_SIZE(headers[2]);
+    memcpy(ptr, headers[2], len);
+    ptr += len;
+  } else {
+  // MARKER_DQT (luma):
+  unsigned tableSize = numQtables == 1 ? qtlen : qtlen/2;
+  *ptr++ = 0xFF; *ptr++ = MARKER_DQT;
+  *ptr++ = 0x00; *ptr++ = tableSize + 3; // size of chunk
+  *ptr++ = 0x00; // precision(0), table id(0)
+  memcpy(ptr, qtables, tableSize);
+  qtables += tableSize;
+  ptr += tableSize;
+
+  if (numQtables > 1) {
+    unsigned tableSize = qtlen - qtlen/2;
+    // MARKER_DQT (chroma):
+    *ptr++ = 0xFF; *ptr++ = MARKER_DQT;
+    *ptr++ = 0x00; *ptr++ = tableSize + 3; // size of chunk
+    *ptr++ = 0x01; // precision(0), table id(1)
+    memcpy(ptr, qtables, tableSize);
+    qtables += tableSize;
+    ptr += tableSize;
+  }
+
+  // MARKER_SOF0:
+  *ptr++ = 0xFF; *ptr++ = MARKER_SOF0;
+  *ptr++ = 0x00; *ptr++ = 0x11; // size of chunk
+  *ptr++ = 0x08; // sample precision
+  *ptr++ = (BYTE)(h >> 8);
+  *ptr++ = (BYTE)(h); // number of lines (must be a multiple of 8)
+  *ptr++ = (BYTE)(w >> 8);
+  *ptr++ = (BYTE)(w); // number of columns (must be a multiple of 8)
+  *ptr++ = 0x03; // number of components
+  *ptr++ = 0x01; // id of component
+  *ptr++ = type ? 0x22 : 0x21; // sampling ratio (h,v)
+  *ptr++ = 0x00; // quant table id
+  *ptr++ = 0x02; // id of component
+  *ptr++ = 0x11; // sampling ratio (h,v)
+  *ptr++ = numQtables == 1 ? 0x00 : 0x01; // quant table id
+  *ptr++ = 0x03; // id of component
+  *ptr++ = 0x11; // sampling ratio (h,v)
+  *ptr++ = 0x01; // quant table id
+  }
+
+  // 0xda: // SOS
+  if (headers[3][0]) { 
+    if (headers[4][0]) {
+      len = CALC_HEADER_SIZE(headers[4]);
+      memcpy(ptr, headers[4], len);
+      ptr += len;
+    }
+    if (headers[6][0]) {
+      len = CALC_HEADER_SIZE(headers[6]);
+      memcpy(ptr, headers[6], len);
+      ptr += len;
+    }
+    if (headers[5][0]) {
+      len = CALC_HEADER_SIZE(headers[5]);
+      memcpy(ptr, headers[5], len);
+      ptr += len;
+    }
+    if (headers[7][0]) {
+      len = CALC_HEADER_SIZE(headers[7]);
+      memcpy(ptr, headers[7], len);
+      ptr += len;
+    }
+    len = CALC_HEADER_SIZE(headers[3]);
+    memcpy(ptr, headers[3], len);
+    ptr += len;
+  } else {
+  createHuffmanHeader(ptr, lum_dc_codelens, sizeof lum_dc_codelens,
+		      lum_dc_symbols, sizeof lum_dc_symbols, 0, 0);
+  createHuffmanHeader(ptr, lum_ac_codelens, sizeof lum_ac_codelens,
+		      lum_ac_symbols, sizeof lum_ac_symbols, 0, 1);
+  createHuffmanHeader(ptr, chm_dc_codelens, sizeof chm_dc_codelens,
+		      chm_dc_symbols, sizeof chm_dc_symbols, 1, 0);
+  createHuffmanHeader(ptr, chm_ac_codelens, sizeof chm_ac_codelens,
+		      chm_ac_symbols, sizeof chm_ac_symbols, 1, 1);
+
+  // MARKER_SOS:
+  *ptr++ = 0xFF;  *ptr++ = MARKER_SOS;
+  *ptr++ = 0x00; *ptr++ = 0x0C; // size of chunk
+  *ptr++ = 0x03; // number of components
+  *ptr++ = 0x01; // id of component
+  *ptr++ = 0x00; // huffman table id (DC, AC)
+  *ptr++ = 0x02; // id of component
+  *ptr++ = 0x11; // huffman table id (DC, AC)
+  *ptr++ = 0x03; // id of component
+  *ptr++ = 0x11; // huffman table id (DC, AC)
+  *ptr++ = 0x00; // start of spectral
+  *ptr++ = 0x3F; // end of spectral
+  *ptr++ = 0x00; // successive approximation bit position (high, low)
+  }
+}
+
+
+jpegExtData extData;
+
+#define FILL_HEADER(n)                                   \
+  if (extData.LastSize > 0)                              \
+  {                                                      \
+    int rem = extData.LastSize;                          \
+    memcpy(extData.headers[n], buffer, rem);             \
+    buffer = bPacket->data();                            \
+    memcpy(extData.headers[n] + rem, buffer, len - rem); \
+    extData.LastSize = 0;                                \
+  }                                                      \
+  else                                                   \
+    memcpy(extData.headers[n], buffer, len);             \
+  extData.lastBuffer = extData.headers[n]
+
+Boolean JPEGVideoRTPSource
+::processExtData(BufferedPacket* bPacket, unsigned extHdr) {
+
+  int size = 4*(extHdr&0xFFFF);
+  const unsigned char* buffer = bPacket->data();
+
+  // image data in plain extension, not in payload (or at least we will skip it)
+  if (extData.UseExtAsPayload)
+  { // very dirty HACK
+    bPacket->removePadding(bPacket->dataSize() - 4*(extHdr&0xFFFF));
+    extData.Ofs = extData.Size;
+    extData.Size += bPacket->dataSize();
+    return True;
+  }
+
+  if (extData.AllProcessed)
+    return False; // this is not first packet
+
+  if (extData.LastSize < 0)
+  {
+    // there were missed bytes on some header from previous packet
+    // add them 
+    memcpy(extData.lastBuffer, buffer, -extData.LastSize);
+    buffer += (-extData.LastSize);
+    size -= (-extData.LastSize);
+    extData.LastSize = 0;
+  }
+  else if (extData.LastSize > 0)
+  {
+    buffer = extData.unparsed;
+    size += extData.LastSize;
+  }
+
+  while (size > 0) {
+    
+    if (*buffer != 0xff) { // we have plain data!!!
+      extData.AllProcessed = true;
+      extData.UseExtAsPayload = true;
+      bPacket->removePadding(bPacket->dataSize() - 4*(extHdr&0xFFFF));
+      bPacket->skip(4*(extHdr&0xFFFF) - size);
+      extData.Ofs = extData.Size;
+      extData.Size += bPacket->dataSize();
+      return true;
+    }
+
+    if (size < 4)
+      break;
+
+    // skip 0xFF if more than 1
+	while(buffer[1] == 0xFF)
+	{
+		buffer++;
+		size--;
+	}
+
+	// calculate ext part len
+    int len = CALC_HEADER_SIZE(buffer);
+    switch (buffer[1]) {
+      case 0xe0: // APP0-JFIF
+        FILL_HEADER(0);
+        if (0) // we will use it if there is a bug on BOSCH side
+        { 
+          unsigned char c = extData.headers[0][15];
+          extData.headers[0][15] = extData.headers[0][13];
+          extData.headers[0][13] = c;
+        }
+        break;
+      case 0xdd: // DRI
+        FILL_HEADER(1);
+        break;
+      case 0xc0: // SOF0
+        FILL_HEADER(2);
+        break;
+      case 0xda: // SOS
+        FILL_HEADER(3);
+        break;
+      case 0xc4: // DHT
+        {
+          int pos = buffer[4];
+          pos =(pos >> 3) | (pos & 15);
+          if (pos < 4) {
+            FILL_HEADER(4 + pos);
+          }
+        }
+        break;
+      case 0xdb: // DQT
+        {
+          int pos = buffer[4];
+          if (pos < 2) {
+            FILL_HEADER(8 + pos);
+          }
+        }
+        break;
+      default:;   // do nothing, skip
+    }
+    buffer += len;
+    size -= len;
+
+    if (size < 0)
+      extData.lastBuffer += (len + size);
+  }
+
+  extData.LastSize = size;
+  // save unparsed data
+  while (size > 0)
+    extData.unparsed[extData.LastSize - size--] = *buffer++;
+
+  return False;
+}
+// AS Fix for additional headers in JPEG
+#endif // ADD_3MP_SUPPORT
+
+
 Boolean JPEGVideoRTPSource
 ::processSpecialHeader(BufferedPacket* packet,
 		       unsigned& resultSpecialHeaderSize) {
@@ -342,9 +770,32 @@
     width = fDefaultWidth;
     height = fDefaultHeight;
   }
+#ifdef ADD_3MP_SUPPORT
+  // check extension's SOF-section for width and height parameters
+  if (extData.headers[2][0]) {
+    fFrameHeight = (extData.headers[2][5] << 8) + extData.headers[2][6];
+    fFrameWidth = (extData.headers[2][7] << 8) + extData.headers[2][8];
+    height = fFrameHeight;
+    width = fFrameWidth;
+  } else {
+    fFrameWidth = width;
+    fFrameHeight = height;
+  }
+#endif
   if (width == 0) width = 256*8; // special case
   if (height == 0) height = 256*8; // special case
 
+#ifdef ADD_3MP_SUPPORT
+  if (extData.UseExtAsPayload) {
+    Offset = extData.Ofs;
+    Type = type = 0;
+    Q = 0;
+    width = 0;
+    height = 0;
+    resultSpecialHeaderSize = 0;
+  }
+#endif
+
   if (Type > 63) {
     // Restart Marker header present
     /*
@@ -393,6 +844,7 @@
 	resultSpecialHeaderSize += Length;
       }
     }
+    //qtlen = 0; // kill this!!!!!!!!!!
   }
 
   // If this is the first (or only) fragment of a JPEG frame, then we need
@@ -413,10 +865,21 @@
       qtlen = sizeof newQtables;
     }
 
+    // AS Fix for additional headers in JPEG
+#ifdef ADD_3MP_SUPPORT
+    if (extData.UseExtAsPayload)
+    {
+      unsigned hdrlen = extData.computeJPEGHeaderSize(qtlen, dri);
+      resultSpecialHeaderSize -= hdrlen; // goes negative
+      headerStart += (int)resultSpecialHeaderSize; // goes backward
+      extData.createJPEGHeader(headerStart, type, width, height, qtables, qtlen, dri);
+    }
+#else
     unsigned hdrlen = computeJPEGHeaderSize(qtlen, dri);
     resultSpecialHeaderSize -= hdrlen; // goes negative
     headerStart += (int)resultSpecialHeaderSize; // goes backward
     createJPEGHeader(headerStart, type, width, height, qtables, qtlen, dri);
+#endif
   }
 
   fCurrentPacketBeginsFrame = (Offset == 0);
@@ -424,6 +887,12 @@
   // The RTP "M" (marker) bit indicates the last fragment of a frame:
   ((JPEGBufferedPacket*)packet)->completesFrame
    = fCurrentPacketCompletesFrame = packet->rtpMarkerBit();
+  
+#ifdef ADD_3MP_SUPPORT
+  if (packet->rtpMarkerBit()) {
+    memset(&extData, 0, sizeof(extData));
+  }
+#endif
 
   return True;
 }
diff -Naur original\live/liveMedia/MediaSession.cpp live/liveMedia/MediaSession.cpp
--- original\live/liveMedia/MediaSession.cpp	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/MediaSession.cpp	2014-11-30 14:36:26.221180100 +0300
@@ -219,6 +219,7 @@
       if (subsession->parseSDPAttribute_source_filter(sdpLine)) continue;
       if (subsession->parseSDPAttribute_x_dimensions(sdpLine)) continue;
       if (subsession->parseSDPAttribute_framerate(sdpLine)) continue;
+      if (subsession->parseSDPAttribute_framesize(sdpLine)) continue;
 #ifdef SUPPORT_REAL_RTSP
       if (RealParseSDPAttributes(subsession, sdpLine)) continue;
 #endif
@@ -287,9 +288,15 @@
 static char* parseCLine(char const* sdpLine) {
   char* resultStr = NULL;
   char* buffer = strDupSize(sdpLine); // ensures we have enough space
-  if (sscanf(sdpLine, "c=IN IP4 %[^/ ]", buffer) == 1) {
+  // AS FIX for correct line end parsing and avoiding wrong DNS lookup
+  // AS FIX allow IPv6 address
+  char IPvNum = '\0';
+  if (sscanf(sdpLine, "c=IN IP%c %[^\r\n^/ ]", &IPvNum, buffer) == 2) {
+  //if (sscanf(sdpLine, "c=IN IP4 %[^/ ]", buffer) == 1) {
     // Later, handle the optional /<ttl> and /<numAddresses> #####
-    resultStr = strDup(buffer);
+    if (IPvNum == '4' || IPvNum == '6') {
+      resultStr = strDup(buffer);
+    }
   }
   delete[] buffer;
 
@@ -398,6 +405,8 @@
   // one of our multicast addresses.  We also don't support more than
   // one <source> #####
   Boolean result = False; // until we succeed
+// AS fix for SONY headers
+return result;
   char* sourceName = strDupSize(sdpLine); // ensures we have enough space
   do {
     if (sscanf(sdpLine, "a=source-filter: incl IN IP4 %*s %s",
@@ -586,7 +595,8 @@
   return fParent.playEndTime();
 }
 
-Boolean MediaSubsession::initiate(int useSpecialRTPoffset) {
+Boolean MediaSubsession::initiate(int useSpecialRTPoffset, 
+                                  RTPSource::RtpExtHdrCallback_t rtpExtHdrCallback, void *pPriv) {
   if (fReadSource != NULL) return True; // has already been initiated
 
   do {
@@ -597,8 +607,12 @@
 
     // Create RTP and RTCP 'Groupsocks' on which to receive incoming data.
     // (Groupsocks will work even for unicast addresses)
+#ifdef LIVE_SUPPORT_IPV6_UDP
+    NetAddress tempAddr = connectionEndpointAddressFull();
+#else
     struct in_addr tempAddr;
     tempAddr.s_addr = connectionEndpointAddress();
+#endif
         // This could get changed later, as a result of a RTSP "SETUP"
 
     if (fClientPortNum != 0) {
@@ -866,6 +880,8 @@
 		   || strcmp(fCodecName, "G726-40") == 0 // G.726, 40 kbps
 		   || strcmp(fCodecName, "SPEEX") == 0 // SPEEX audio
 		   || strcmp(fCodecName, "T140") == 0 // T.140 text (RFC 4103)
+// AS Fix for ONVIF metadata
+       || stricmp(fCodecName, "VND.ONVIF.METADATA") == 0
 		   ) {
 	createSimpleRTPSource = True;
 	useSpecialRTPoffset = 0;
@@ -896,6 +912,11 @@
       break;
     }
 
+    // AS callback for getting RTP packets extensions
+    if (MultiFramedRTPSource *MFRTPSource = dynamic_cast<MultiFramedRTPSource*>(fReadSource)) {
+      MFRTPSource->setRtpExtHdrCallback(rtpExtHdrCallback, pPriv);
+    }
+
     // Finally, create our RTCP instance. (It starts running automatically)
     if (fRTPSource != NULL) {
       // If bandwidth is specified, use it and add 5% for RTCP overhead.
@@ -988,6 +1009,52 @@
   }
 }
 
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+NetAddress MediaSubsession::connectionEndpointAddressFull() const {
+  do {
+    // Get the endpoint name from with us, or our parent session:
+    char const* endpointString = connectionEndpointName();
+    if (endpointString == NULL) {
+      endpointString = parentSession().connectionEndpointName();
+    }
+    if (endpointString == NULL) break;
+
+    // Now, convert this name to an address, if we can:
+    NetAddressList addresses(endpointString);
+    if (addresses.numAddresses() == 0) break;
+
+    return *addresses.firstAddress();
+  } while (0);
+
+  // No address known:
+  return NetAddress();
+}
+
+void MediaSubsession::setDestinationsFull(NetAddress defaultDestAddress) {
+  // Get the destination address from the connection endpoint name
+  // (This will be 0 if it's not known, in which case we use the default)
+  NetAddress destAddress = connectionEndpointAddressFull();
+  if (!destAddress.IsNotZero()) destAddress = defaultDestAddress;
+
+  // The destination TTL remains unchanged:
+  int destTTL = ~0; // means: don't change
+
+  if (fRTPSocket != NULL) {
+    Port destPort(serverPortNum);
+    fRTPSocket->changeDestinationParametersFull(destAddress, destPort, destTTL);
+  }
+  if (fRTCPSocket != NULL && !isSSM()) {
+    // Note: For SSM sessions, the dest address for RTCP was already set.
+    Port destPort(serverPortNum+1);
+    fRTCPSocket->
+      changeDestinationParametersFull(destAddress, destPort, destTTL);
+  }
+}
+
+#endif
+
+
 double MediaSubsession::getNormalPlayTime(struct timeval const& presentationTime) {
   // First, check whether our "RTPSource" object has already been synchronized using RTCP.
   // If it hasn't, then - as a special case - we need to use the RTP timestamp to compute the NPT.
@@ -1259,3 +1326,27 @@
 
   return parseSuccess;
 }
+
+// AS Fix: field from RFC6064
+Boolean MediaSubsession::parseSDPAttribute_framesize(char const* sdpLine) {
+  // Check for a "a=framesize:<payload type number> <width>-<height>" line:
+  Boolean parseSuccess = False;
+
+  int width, height, payload;
+  if (sscanf(sdpLine, "a=framesize:%d %d-%d", &payload, &width, &height) == 3) {
+    parseSuccess = True;
+    fVideoWidth = (unsigned short)width;
+    fVideoHeight = (unsigned short)height;
+  }
+
+  return parseSuccess;
+}
+
+Boolean MediaSubsession::IsValidMulticastEndpointAddress() const {
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+  return IsMulticastAddress(connectionEndpointAddressFull());
+#else
+  return IsMulticastAddress(connectionEndpointAddress()); 
+#endif
+}
diff -Naur original\live/liveMedia/MultiFramedRTPSource.cpp live/liveMedia/MultiFramedRTPSource.cpp
--- original\live/liveMedia/MultiFramedRTPSource.cpp	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/MultiFramedRTPSource.cpp	2014-12-08 21:45:16.207623000 +0300
@@ -71,6 +71,9 @@
 
   // Try to use a big receive buffer for RTP:
   increaseReceiveBufferTo(env, RTPgs->socketNum(), 50*1024);
+
+  fRtpExtHdrCallback = NULL;
+  fCheckPldTypeCallback = NULL;
 }
 
 void MultiFramedRTPSource::reset() {
@@ -123,6 +126,11 @@
   doGetNextFrame1();
 }
 
+// AS Fix for checking JPEG header
+// 1: processed; 2: failed; 3: not processed in this step
+u_int8_t SpecialHeaderStatus;
+
+
 void MultiFramedRTPSource::doGetNextFrame1() {
   while (fNeedDelivery) {
     // If we already have packet data available, then deliver it now.
@@ -141,10 +149,17 @@
 	// Something's wrong with the header; reject the packet:
 	fReorderingBuffer->releaseUsedPacket(nextPacket);
 	fNeedDelivery = True;
+        // AS Fix header status
+        SpecialHeaderStatus = 2;
 	break;
       }
+      // AS Fix header status
+      SpecialHeaderStatus = 1;
+
       nextPacket->skip(specialHeaderSize);
-    }
+    } 
+    // AS Fix header status
+    else SpecialHeaderStatus = 3;
 
     // Check whether we're part of a multi-packet frame, and whether
     // there was packet loss that would render this packet unusable:
@@ -213,6 +228,10 @@
 }
 
 #define ADVANCE(n) do { bPacket->skip(n); } while (0)
+// AS fix for JPEG aspect ratio header
+int Un, xD, yD;
+// AS fix for JPEG size header
+int xSize, ySize;
 
 void MultiFramedRTPSource::networkReadHandler(MultiFramedRTPSource* source,
 					      int /*mask*/) {
@@ -220,6 +239,13 @@
   BufferedPacket* bPacket
     = source->fReorderingBuffer->getFreePacket(source);
 
+  // AS fix for replay extension header
+  u_int32_t extensionData[5] = {0, 0, 0, 0, 0};
+  unsigned seqNumber = 0;
+  bool readExtension = false;
+  unsigned rtpHdr = 0;
+  unsigned extHdr = 0;
+
   // Read the network packet, and perform sanity checks on the RTP header:
   Boolean readSuccess = False;
   do {
@@ -232,7 +258,8 @@
 
     // Check for the 12-byte RTP header:
     if (bPacket->dataSize() < 12) break;
-    unsigned rtpHdr = ntohl(*(unsigned*)(bPacket->data())); ADVANCE(4);
+    rtpHdr = ntohl(*(unsigned*)(bPacket->data())); ADVANCE(2);
+    seqNumber = *(unsigned*)(bPacket->data()); ADVANCE(2);
     Boolean rtpMarkerBit = (rtpHdr&0x00800000) >> 23;
     unsigned rtpTimestamp = ntohl(*(unsigned*)(bPacket->data()));ADVANCE(4);
     unsigned rtpSSRC = ntohl(*(unsigned*)(bPacket->data())); ADVANCE(4);
@@ -245,13 +272,52 @@
     if (bPacket->dataSize() < cc) break;
     ADVANCE(cc*4);
 
+    // AS fix for JPEG aspect ratio header
+    Un = 0;
+    xD = 0;
+    yD = 0;
+    // AS fix for JPEG size header
+    xSize = 0;
+    ySize = 0;
+
     // Check for (& ignore) any RTP header extension
     if (rtpHdr&0x10000000) {
       if (bPacket->dataSize() < 4) break;
-      unsigned extHdr = ntohl(*(unsigned*)(bPacket->data())); ADVANCE(4);
+      extHdr = ntohl(*(unsigned*)(bPacket->data())); ADVANCE(4);
       unsigned remExtSize = 4*(extHdr&0xFFFF);
       if (bPacket->dataSize() < remExtSize) break;
-      ADVANCE(remExtSize);
+
+      // AS Fix for additional replay header
+      if ((extHdr >> 16) == 0xABAC) {
+        readExtension = true;
+        memcpy(extensionData, bPacket->data(), 12);
+        extensionData[2] += ((extHdr & 0xFFFF) < 3 ? 0 : 1) << 16;
+        if ((extHdr & 0xFFFF) > 3) {
+          ADVANCE(12);
+          if (bPacket->dataSize() < 4) break;
+          extHdr = ntohl(*(unsigned*)(bPacket->data())); ADVANCE(4);
+          remExtSize = 4*(extHdr&0xFFFF);
+          if (bPacket->dataSize() < remExtSize) break;
+        }
+      }
+
+      // AS Fix for additional headers in JPEG
+#ifdef ADD_3MP_SUPPORT
+      if (!source->processExtData(bPacket, extHdr)) {
+        ADVANCE(remExtSize);
+      }
+#endif
+      // AS fix for JPEG aspect ratio header
+      // AS fix for JPEG size header
+/*      if (((DWORD*)bPacket->data())[1] == 0x4649464a)
+      {
+        OutputDebugStringA("JFIF present\n");
+        xSize = bPacket->data()[0xa4] + (((int)(bPacket->data()[0xa3])) << 8);
+        ySize = bPacket->data()[0xa2] + (((int)(bPacket->data()[0xa1])) << 8);
+        Un = bPacket->data()[11];
+        xD = bPacket->data()[13];
+        yD = bPacket->data()[15];
+      }*/
     }
 
     // Discard any padding bytes:
@@ -263,8 +329,14 @@
       bPacket->removePadding(numPaddingBytes);
     }
     // Check the Payload Type.
-    if ((unsigned char)((rtpHdr&0x007F0000)>>16)
-	!= source->rtpPayloadFormat()) {
+    if (source->fCheckPldTypeCallback) {
+      if (!source->fCheckPldTypeCallback(
+            (unsigned char)((rtpHdr&0x007F0000)>>16), 
+            bPacket->data(), 
+            bPacket->dataSize(),
+            source->fCheckPldTypeCallbackPrivData))
+        break;
+    } else if ((unsigned char)((rtpHdr&0x007F0000)>>16) != source->rtpPayloadFormat()) {
       break;
     }
 
@@ -294,8 +366,34 @@
   } while (0);
   if (!readSuccess) source->fReorderingBuffer->freePacket(bPacket);
 
+  // AS Fix header status
+  SpecialHeaderStatus = 0;
+
   source->doGetNextFrame1();
   // If we didn't get proper data this time, we'll get another chance
+
+  if (source->fRtpExtHdrCallback && ((extHdr >> 16) == 0xFFD8 || (extHdr >> 16) == 0xFFFF)) {
+    extensionData[0] = SpecialHeaderStatus;
+    extensionData[1] = source->fCurrentPacketBeginsFrame ? 1 : 0;
+    source->fRtpExtHdrCallback(
+      (extHdr >> 16), seqNumber, sizeof(extensionData), 
+      (u_int8_t*)extensionData, source->fRtpExtHdrCallbackPrivData); 
+  }
+
+
+  // AS callback for replay header extension
+  if (readExtension && source->fRtpExtHdrCallback) {
+    extensionData[2] += ((source->fCurrentPacketBeginsFrame                ? 1 << 1 : 0) << 16) 
+                        + ((source->fCurrentPacketCompletesFrame           ? 1 << 2 : 0) << 16) 
+                        + ((source->fCurPacketHasBeenSynchronizedUsingRTCP ? 1 << 3 : 0) << 16)
+                        + ((source->fCurPacketMarkerBit                    ? 1 << 4 : 0) << 16);
+    extensionData[3] = source->fCurPacketRTPTimestamp;
+    // payload type
+    extensionData[4] = (unsigned char)((rtpHdr & 0x007F0000) >> 16);
+    source->fRtpExtHdrCallback(
+      0xABAC, seqNumber, 
+      sizeof(extensionData), (u_int8_t*)extensionData, source->fRtpExtHdrCallbackPrivData); 
+  }
 }
 
 
diff -Naur original\live/liveMedia/RTCP.cpp live/liveMedia/RTCP.cpp
--- original\live/liveMedia/RTCP.cpp	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/RTCP.cpp	2014-11-30 14:36:26.240183700 +0300
@@ -117,6 +117,20 @@
 	// bytes (1500, minus some allowance for IP, UDP, UMTP headers)
 static unsigned const preferredPacketSize = 1000; // bytes
 
+#ifdef DEBUG
+int RTCPInstance::fprintf(FILE *Tmp, const char *Format, ...)
+{
+  va_list ap;
+  char Buffer[2048];
+  int size = 0;
+  va_start(ap, Format);
+  size += _vsnprintf(Buffer + size, sizeof(Buffer), Format, ap);
+  va_end(ap);
+  envir() << Buffer;
+  return size;
+}
+#endif
+
 RTCPInstance::RTCPInstance(UsageEnvironment& env, Groupsock* RTCPgs,
 			   unsigned totSessionBW,
 			   unsigned char const* cname,
@@ -280,13 +294,15 @@
   }
 }
 
+// AS fix for concurrect access to reading socket in TCP mode
 void RTCPInstance::setStreamSocket(int sockNum,
-				   unsigned char streamChannelId) {
+				   unsigned char streamChannelId,
+				   CRITICAL_SECTION *pCriticalSection) {
   // Turn off background read handling:
   fRTCPInterface.stopNetworkReading();
 
   // Switch to RTCP-over-TCP:
-  fRTCPInterface.setStreamSocket(sockNum, streamChannelId);
+  fRTCPInterface.setStreamSocket(sockNum, streamChannelId, pCriticalSection);
 
   // Turn background reading back on:
   TaskScheduler::BackgroundHandlerProc* handler
@@ -925,10 +941,13 @@
   instance->reschedule(nextTime);
 }
 
+// hack
+// AS Fix for something unknown
+int InPlayMode = 0;
 extern "C" void SendRTCPReport(event e) {
   RTCPInstance* instance = (RTCPInstance*)e;
   if (instance == NULL) return;
-
+if (InPlayMode)
   instance->sendReport();
 }
 
diff -Naur original\live/liveMedia/RTPInterface.cpp live/liveMedia/RTPInterface.cpp
--- original\live/liveMedia/RTPInterface.cpp	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/RTPInterface.cpp	2014-11-30 14:36:26.251184200 +0300
@@ -56,6 +56,8 @@
   RTPInterface* lookupRTPInterface(unsigned char streamChannelId);
   void deregisterRTPInterface(unsigned char streamChannelId);
 
+// AS fix for concurrect access to reading socket in TCP mode
+  CRITICAL_SECTION *GetCriticalSection() const;
 private:
   static void tcpReadHandler(SocketDescriptor*, int mask);
 
@@ -65,6 +67,26 @@
   HashTable* fSubChannelHashTable;
 };
 
+// AS fix for concurrect access to reading socket in TCP mode
+CRITICAL_SECTION * SocketDescriptor::GetCriticalSection() const
+{
+  if (fSubChannelHashTable->IsEmpty())
+    return 0;
+
+
+  HashTable::Iterator *i = HashTable::Iterator::create(*fSubChannelHashTable);
+  const char* b;
+  while (i->next(b)) {
+    RTPInterface* r = (RTPInterface*)(fSubChannelHashTable->Lookup(b));
+    if (!r)
+      continue;
+    if (r->pCriticalSection) {
+      return r->pCriticalSection;
+    }
+  }
+  return 0;
+}
+
 static SocketDescriptor* lookupSocketDescriptor(UsageEnvironment& env,
 						int sockNum) {
   char const* key = (char const*)(long)sockNum;
@@ -108,9 +130,12 @@
 
 Boolean RTPOverTCP_OK = True; // HACK: For detecting TCP socket failure externally #####
 
+// AS fix for concurrect access to reading socket in TCP mode
 void RTPInterface::setStreamSocket(int sockNum,
-				   unsigned char streamChannelId) {
+				   unsigned char streamChannelId,
+				   CRITICAL_SECTION *pCriticalSection) {
   fGS->removeAllDestinations();
+  this->pCriticalSection = pCriticalSection;
   addStreamSocket(sockNum, streamChannelId);
 }
 
@@ -322,12 +347,37 @@
   }
 }
 
+// AS fix for concurrect access to reading socket in TCP mode
+class Unlocker {
+CRITICAL_SECTION *pCriticalSection;
+public:
+  Unlocker(CRITICAL_SECTION *p = 0) : pCriticalSection(p) {};
+ ~Unlocker() {
+    if (pCriticalSection) LeaveCriticalSection(pCriticalSection);
+  };
+  void Select(CRITICAL_SECTION *p = 0) 
+  { 
+    if (pCriticalSection && (pCriticalSection != p)) {
+      LeaveCriticalSection(pCriticalSection);
+    }
+    pCriticalSection = p; 
+  };
+};
+
+extern int QuickSocketNumber;
+extern unsigned char QuickstreamChannelId;
+extern unsigned short Quicksize;
+
 void SocketDescriptor::tcpReadHandler(SocketDescriptor* socketDescriptor,
-				      int mask) {
+  				      int mask) {
   do {
     UsageEnvironment& env = socketDescriptor->fEnv; // abbrev
     int socketNum = socketDescriptor->fOurSocketNum;
 
+// AS fix for concurrect access to reading socket in TCP mode
+    Unlocker unlocker;
+    CRITICAL_SECTION *pCriticalSection = socketDescriptor->GetCriticalSection();
+
     // Begin by reading and discarding any characters that aren't '$'.
     // Any such characters are probably regular RTSP responses or
     // commands from the server.  At present, we can't do anything with
@@ -336,13 +386,36 @@
     unsigned char c;
     struct sockaddr_in fromAddress;
     struct timeval timeout; timeout.tv_sec = 0; timeout.tv_usec = 0;
+
+// AS fix for concurrect access to reading socket in TCP mode
+    if (pCriticalSection) {
+      blockUntilReadable(env, socketNum, &timeout);
+      EnterCriticalSection(pCriticalSection);
+      unlocker.Select(pCriticalSection);
+    }
+
+  if (Quicksize && (QuickSocketNumber == socketNum)) {
+    RTPInterface* rtpInterface
+      = socketDescriptor->lookupRTPInterface(QuickstreamChannelId);
+    if (!rtpInterface || !rtpInterface->fReadHandlerProc) {
+        Quicksize = 0;
+	break; // we're not interested in this channel
+    }
+    rtpInterface->fNextTCPReadSize = Quicksize;
+    rtpInterface->fNextTCPReadStreamSocketNum = QuickSocketNumber;
+    rtpInterface->fNextTCPReadStreamChannelId = QuickstreamChannelId;
+    rtpInterface->fReadHandlerProc(rtpInterface->fOwner, mask);
+    Quicksize = 0;
+  } else {
     do {
       int result = readSocket(env, socketNum, &c, 1, fromAddress, &timeout);
       if (result != 1) { // error reading TCP socket
-	if (result < 0) {
-	  env.taskScheduler().turnOffBackgroundReadHandling(socketNum); // stops further calls to us
-	}
-	return;
+	      if (result < 0) {
+          // AS fix for strange things with HTTP tunneling - thanks to Michio Hirai & BalaKrishna Vinturi
+          // TODO move fix to readSocket routine
+	        //env.taskScheduler().turnOffBackgroundReadHandling(socketNum); // stops further calls to us
+	      }
+	      return;
       }
     } while (c != '$');
 
@@ -370,6 +443,7 @@
     if (rtpInterface->fReadHandlerProc != NULL) {
       rtpInterface->fReadHandlerProc(rtpInterface->fOwner, mask);
     }
+  }
 
   } while (0);
 }
diff -Naur original\live/liveMedia/RTSPClient.cpp live/liveMedia/RTSPClient.cpp
--- original\live/liveMedia/RTSPClient.cpp	2009-11-27 13:25:55.000000000 +0300
+++ live/liveMedia/RTSPClient.cpp	2014-12-01 14:18:28.961022900 +0300
@@ -70,10 +70,16 @@
     fRealChallengeStr(NULL), fRealETagStr(NULL),
 #endif
     fServerIsKasenna(False), fKasennaContentType(NULL),
-    fServerIsMicrosoft(False)
+    fServerIsMicrosoft(False), fBase64LineBreaks(false), fCustomFields(NULL), fSocketReadAllMode(false), fSetupDestination(NULL)
 {
   fResponseBufferSize = 20000;
+  //fRequestBufferSize = 20000;
   fResponseBuffer = new char[fResponseBufferSize+1];
+  fResponseBuffer2 = new char[fResponseBufferSize+1];
+  fRtspRequestBuffer = new char[20000];
+  fRtspResponseBuffer = new char[20000];
+  fRtspRequestBuffer[0] = '\0';
+  fRtspResponseBuffer[0] = '\0';
 
   // Set the "User-Agent:" header to use in each request:
   char const* const libName = "LIVE555 Streaming Media v";
@@ -93,6 +99,10 @@
   sprintf(fUserAgentHeaderStr, formatStr,
 	  applicationName, libPrefix, libName, libVersionStr, libSuffix);
   fUserAgentHeaderStrSize = strlen(fUserAgentHeaderStr);
+  // AS fix - start new session from 0
+  fCSeq = 0;
+
+  InitializeCriticalSection(&fCriticalSection);
 }
 
 void RTSPClient::setUserAgentString(char const* userAgentStr) {
@@ -112,7 +122,12 @@
   reset();
 
   delete[] fResponseBuffer;
+  delete[] fResponseBuffer2;
+  delete[] fRtspRequestBuffer;
+  delete[] fRtspResponseBuffer;
   delete[] fUserAgentHeaderStr;
+
+  DeleteCriticalSection(&fCriticalSection);
 }
 
 Boolean RTSPClient::isRTSPClient() const {
@@ -209,7 +224,7 @@
     cmd = new char[cmdSize];
     sprintf(cmd, cmdFmt,
 	    url,
-	    ++fCSeq,
+	    fCSeq++,
             acceptStr,
 	    authenticatorStr,
 	    fUserAgentHeaderStr);
@@ -557,7 +572,7 @@
     cmd = new char[cmdSize];
     sprintf(cmd, cmdFmt,
 	    url,
-	    ++fCSeq,
+	    fCSeq++,
 	    authenticatorStr,
 	    fUserAgentHeaderStr);
     delete[] authenticatorStr;
@@ -569,6 +584,7 @@
     char* firstLine; char* nextLineStart;
     if (!getResponse("OPTIONS", bytesRead, responseCode, firstLine, nextLineStart,
 		     False /*don't check for response code 200*/)) break;
+
     if (responseCode != 200) {
       checkForAuthenticationFailure(responseCode, nextLineStart, authenticator);
       envir().setResultMsg("cannot handle OPTIONS response: ", firstLine);
@@ -678,7 +694,7 @@
     cmd = new char[cmdSize];
     sprintf(cmd, cmdFmt,
 	    url,
-	    ++fCSeq,
+	    fCSeq++,
 	    authenticatorStr,
 	    sdpSize,
 	    sdpDescription);
@@ -798,7 +814,10 @@
 	  Boolean requestMulticastStreaming = IsMulticastAddress(connectionAddress)
 	    || (connectionAddress == 0 && forceMulticastOnUnspecified);
 	  transportTypeStr = requestMulticastStreaming ? ";multicast" : ";unicast";
-	  portTypeStr = ";client_port";
+// AS Fix basing on http://www.ietf.org/rfc/rfc2326.txt - page 59
+//	  portTypeStr = ";client_port";
+	  portTypeStr = requestMulticastStreaming ? ";port" : ";client_port";
+// AS Fix end
 	  rtpNumber = subsession.clientPortNum();
 	  if (rtpNumber == 0) {
 	    envir().setResultMsg("Client port number unknown\n");
@@ -848,7 +867,7 @@
       setupStr = new char[setupSize];
       sprintf(setupStr, setupFmt, prefix, separator);
 
-      transportFmt = "Transport: RAW/RAW/UDP%s%s%s=%d-%d\r\n";
+      transportFmt = "Transport: RAW/RAW/UDP%s%s%s%s=%d-%d\r\n";
     } else {
       char const* setupFmt = "SETUP %s%s%s RTSP/1.0\r\n";
       unsigned setupSize = strlen(setupFmt)
@@ -856,7 +875,7 @@
       setupStr = new char[setupSize];
       sprintf(setupStr, setupFmt, prefix, separator, suffix);
 
-      transportFmt = "Transport: RTP/AVP%s%s%s=%d-%d\r\n";
+      transportFmt = "Transport: RTP/AVP%s%s%s%s=%d-%d\r\n";
     }
 
     if (transportStr == NULL) {
@@ -872,11 +891,21 @@
 	rtpNumber = fTCPStreamIdCount++;
 	rtcpNumber = fTCPStreamIdCount++;
       } else { // normal RTP streaming
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+  NetAddress connectionAddress = subsession.connectionEndpointAddressFull();
+	Boolean requestMulticastStreaming = IsMulticastAddress(connectionAddress)
+    || (!connectionAddress.IsNotZero() && forceMulticastOnUnspecified);
+#else
 	unsigned connectionAddress = subsession.connectionEndpointAddress();
 	Boolean requestMulticastStreaming = IsMulticastAddress(connectionAddress)
 	  || (connectionAddress == 0 && forceMulticastOnUnspecified);
+#endif
 	transportTypeStr = requestMulticastStreaming ? ";multicast" : ";unicast";
-	portTypeStr = ";client_port";
+// AS Fix basing on http://www.ietf.org/rfc/rfc2326.txt - page 59
+//	portTypeStr = ";client_port";
+	portTypeStr = requestMulticastStreaming ? ";port" : ";client_port";
+// AS Fix end
 	rtpNumber = subsession.clientPortNum();
 	if (rtpNumber == 0) {
 	  envir().setResultMsg("Client port number unknown\n");
@@ -887,12 +916,18 @@
       }
 
       unsigned transportSize = strlen(transportFmt)
+        + strlen(fSetupDestination) // AS Fix destination setting for SETUP command
 	+ strlen(transportTypeStr) + strlen(modeStr) + strlen(portTypeStr) + 2*5 /* max port len */;
       transportStr = new char[transportSize];
       sprintf(transportStr, transportFmt,
-	      transportTypeStr, modeStr, portTypeStr, rtpNumber, rtcpNumber);
+	      transportTypeStr,
+        fSetupDestination, // AS Fix destination setting for SETUP command
+        modeStr, portTypeStr, rtpNumber, rtcpNumber);
     }
 
+// AS Fix custom string to add to RTSP command
+    char *additionalFields = fCustomFields;
+
     // (Later implement more, as specified in the RTSP spec, sec D.1 #####)
     char const* const cmdFmt =
       "%s"
@@ -901,6 +936,7 @@
       "%s"
       "%s"
       "%s"
+      "%s" // AS custom fields
       "\r\n";
 
     unsigned cmdSize = strlen(cmdFmt)
@@ -909,24 +945,38 @@
       + strlen(transportStr)
       + strlen(sessionStr)
       + strlen(authenticatorStr)
-      + fUserAgentHeaderStrSize;
+      + fUserAgentHeaderStrSize
+      // AS custom fields
+      + (additionalFields ? strlen(additionalFields) : 0);
     cmd = new char[cmdSize];
     sprintf(cmd, cmdFmt,
 	    setupStr,
-	    ++fCSeq,
+	    fCSeq++,
 	    transportStr,
 	    sessionStr,
 	    authenticatorStr,
-	    fUserAgentHeaderStr);
+	    fUserAgentHeaderStr,
+      // AS custom fields
+      additionalFields ? additionalFields : "");
     delete[] authenticatorStr; delete[] sessionStr; delete[] setupStr; delete[] transportStr;
 
+    EnterCriticalSection(&fCriticalSection);
+
     // And then send it:
-    if (!sendRequest(cmd, "SETUP")) break;
+    if (!sendRequest(cmd, "SETUP")) {
+		LeaveCriticalSection(&fCriticalSection);
+		break;
+	}
 
     // Get the response from the server:
     unsigned bytesRead; unsigned responseCode;
     char* firstLine; char* nextLineStart;
-    if (!getResponse("SETUP", bytesRead, responseCode, firstLine, nextLineStart)) break;
+    if (!getResponse("SETUP", bytesRead, responseCode, firstLine, nextLineStart)) {
+		LeaveCriticalSection(&fCriticalSection);
+		break;
+	}
+
+    LeaveCriticalSection(&fCriticalSection);
 
     // Look for a "Session:" header (to set our session id), and
     // a "Transport: " header (to set the server address/port)
@@ -991,18 +1041,33 @@
       // Tell the subsession to receive RTP (and send/receive RTCP)
       // over the RTSP stream:
       if (subsession.rtpSource() != NULL)
-	subsession.rtpSource()->setStreamSocket(fInputSocketNum,
-						subsession.rtpChannelId);
+// AS fix for concurrect access to reading socket in TCP mode
+        subsession.rtpSource()->setStreamSocket(fInputSocketNum, subsession.rtpChannelId, &fCriticalSection);
+
       if (subsession.rtcpInstance() != NULL)
-	subsession.rtcpInstance()->setStreamSocket(fInputSocketNum,
-						   subsession.rtcpChannelId);
+// AS fix for concurrect access to reading socket in TCP mode
+        subsession.rtcpInstance()->setStreamSocket(fInputSocketNum, subsession.rtcpChannelId, &fCriticalSection);
+
     } else {
       // Normal case.
       // Set the RTP and RTCP sockets' destination address and port
       // from the information in the SETUP response (if present):
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_UDP
+      NetAddress destAddressFull = subsession.connectionEndpointAddressFull();
+      if (destAddressFull.IsNotZero())
+      {
+        subsession.setDestinationsFull(destAddressFull);
+      }
+      else
+      {
+        subsession.setDestinationsFull(fServerAddressFull);
+      }
+#else
       netAddressBits destAddress = subsession.connectionEndpointAddress();
       if (destAddress == 0) destAddress = fServerAddress;
       subsession.setDestinations(destAddress);
+#endif
     }
 
     delete[] cmd;
@@ -1074,6 +1139,9 @@
     // And then a "Range:" string:
     char* rangeStr = createRangeString(start, end);
 
+// AS Fix custom string to add to RTSP command
+    char *additionalFields = fCustomFields;
+
     char const* const cmdFmt =
       "PLAY %s RTSP/1.0\r\n"
       "CSeq: %d\r\n"
@@ -1082,6 +1150,7 @@
       "%s"
       "%s"
       "%s"
+      "%s" // AS custom fields
       "\r\n";
 
     char const* sessURL = sessionURL(session);
@@ -1092,26 +1161,40 @@
       + strlen(scaleStr)
       + strlen(rangeStr)
       + strlen(authenticatorStr)
-      + fUserAgentHeaderStrSize;
+      + fUserAgentHeaderStrSize
+      // AS custom fields
+      + (additionalFields ? strlen(additionalFields) : 0);
     cmd = new char[cmdSize];
     sprintf(cmd, cmdFmt,
 	    sessURL,
-	    ++fCSeq,
+	    fCSeq++,
 	    fLastSessionId,
 	    scaleStr,
 	    rangeStr,
 	    authenticatorStr,
-	    fUserAgentHeaderStr);
+	    fUserAgentHeaderStr,
+      // AS custom fields
+      additionalFields ? additionalFields : "");
     delete[] scaleStr;
     delete[] rangeStr;
     delete[] authenticatorStr;
 
-    if (!sendRequest(cmd, "PLAY")) break;
+    EnterCriticalSection(&fCriticalSection); 
+
+    if (!sendRequest(cmd, "PLAY")) {
+		LeaveCriticalSection(&fCriticalSection);
+		break;
+	}
 
     // Get the response from the server:
     unsigned bytesRead; unsigned responseCode;
     char* firstLine; char* nextLineStart;
-    if (!getResponse("PLAY", bytesRead, responseCode, firstLine, nextLineStart)) break;
+    if (!getResponse("PLAY", bytesRead, responseCode, firstLine, nextLineStart)) {
+		LeaveCriticalSection(&fCriticalSection);
+		break;
+	}
+
+    LeaveCriticalSection(&fCriticalSection);
 
     // Look for various headers that we understand:
     char* lineStart;
@@ -1206,7 +1289,7 @@
     cmd = new char[cmdSize];
     sprintf(cmd, cmdFmt,
 	    prefix, separator, suffix,
-	    ++fCSeq,
+	    fCSeq++,
 	    subsession.sessionId,
 	    scaleStr,
 	    rangeStr,
@@ -1216,12 +1299,22 @@
     delete[] rangeStr;
     delete[] authenticatorStr;
 
-    if (!sendRequest(cmd, "PLAY")) break;
+    EnterCriticalSection(&fCriticalSection);
+
+    if (!sendRequest(cmd, "PLAY")) {
+		LeaveCriticalSection(&fCriticalSection);
+		break;
+	}
 
     // Get the response from the server:
     unsigned bytesRead; unsigned responseCode;
     char* firstLine; char* nextLineStart;
-    if (!getResponse("PLAY", bytesRead, responseCode, firstLine, nextLineStart)) break;
+    if (!getResponse("PLAY", bytesRead, responseCode, firstLine, nextLineStart)) {
+		LeaveCriticalSection(&fCriticalSection);
+		break;
+	}
+
+    LeaveCriticalSection(&fCriticalSection);
 
     // Look for various headers that we understand:
     char* lineStart;
@@ -1266,6 +1359,9 @@
     char* authenticatorStr
       = createAuthenticatorString(&fCurrentAuthenticator, "PAUSE", fBaseURL);
 
+// AS Fix custom string to add to RTSP command
+    char *additionalFields = fCustomFields;
+
     char const* sessURL = sessionURL(session);
     char const* const cmdFmt =
       "PAUSE %s RTSP/1.0\r\n"
@@ -1273,6 +1369,7 @@
       "Session: %s\r\n"
       "%s"
       "%s"
+      "%s" // AS custom fields
       "\r\n";
 
     unsigned cmdSize = strlen(cmdFmt)
@@ -1280,25 +1377,39 @@
       + 20 /* max int len */
       + strlen(fLastSessionId)
       + strlen(authenticatorStr)
-      + fUserAgentHeaderStrSize;
+      + fUserAgentHeaderStrSize
+      // AS custom fields
+      + (additionalFields ? strlen(additionalFields) : 0);
     cmd = new char[cmdSize];
     sprintf(cmd, cmdFmt,
 	    sessURL,
-	    ++fCSeq,
+	    fCSeq++,
 	    fLastSessionId,
 	    authenticatorStr,
-	    fUserAgentHeaderStr);
+	    fUserAgentHeaderStr,
+      // AS custom fields
+      additionalFields ? additionalFields : "");
     delete[] authenticatorStr;
 
-    if (!sendRequest(cmd, "PAUSE")) break;
+    EnterCriticalSection(&fCriticalSection); 
+
+    if (!sendRequest(cmd, "PAUSE"))	{
+		LeaveCriticalSection(&fCriticalSection);
+		break;
+	}
 
     if (fTCPStreamIdCount == 0) { // When TCP streaming, don't look for a response
       // Get the response from the server:
       unsigned bytesRead; unsigned responseCode;
       char* firstLine; char* nextLineStart;
-      if (!getResponse("PAUSE", bytesRead, responseCode, firstLine, nextLineStart)) break;
+      if (!getResponse("PAUSE", bytesRead, responseCode, firstLine, nextLineStart)) {
+		  LeaveCriticalSection(&fCriticalSection);
+		  break;
+	  }
     }
 
+    LeaveCriticalSection(&fCriticalSection);
+
     delete[] cmd;
     return True;
   } while (0);
@@ -1343,21 +1454,31 @@
     cmd = new char[cmdSize];
     sprintf(cmd, cmdFmt,
 	    prefix, separator, suffix,
-	    ++fCSeq,
+	    fCSeq++,
 	    subsession.sessionId,
 	    authenticatorStr,
 	    fUserAgentHeaderStr);
     delete[] authenticatorStr;
 
-    if (!sendRequest(cmd, "PAUSE")) break;
+    EnterCriticalSection(&fCriticalSection);
+
+    if (!sendRequest(cmd, "PAUSE")) {
+		LeaveCriticalSection(&fCriticalSection);
+		break;
+	}
 
     if (fTCPStreamIdCount == 0) { // When TCP streaming, don't look for a response
       // Get the response from the server:
       unsigned bytesRead; unsigned responseCode;
       char* firstLine; char* nextLineStart;
-      if (!getResponse("PAUSE", bytesRead, responseCode, firstLine, nextLineStart)) break;
+      if (!getResponse("PAUSE", bytesRead, responseCode, firstLine, nextLineStart)) {
+		  LeaveCriticalSection(&fCriticalSection);
+		  break;
+	  }
     }
 
+    LeaveCriticalSection(&fCriticalSection);
+
     delete[] cmd;
     return True;
   } while (0);
@@ -1403,7 +1524,7 @@
     cmd = new char[cmdSize];
     sprintf(cmd, cmdFmt,
 	    prefix, separator, suffix,
-	    ++fCSeq,
+	    fCSeq++,
 	    subsession.sessionId,
 	    authenticatorStr,
 	    fUserAgentHeaderStr);
@@ -1428,6 +1549,8 @@
 					     char const* parameterName,
 					     char const* parameterValue) {
   char* cmd = NULL;
+  int Retry = 0;
+rep:
   do {
     // First, make sure that we have a RTSP session in progress
     if (fLastSessionId == NULL) {
@@ -1461,22 +1584,59 @@
       + fUserAgentHeaderStrSize
       + parameterNameLen + parameterValueLen;
     cmd = new char[cmdSize];
-    sprintf(cmd, cmdFmt,
+
+    // hack for KEP_ALIVE
+#if 1
+    if (!parameterNameLen && !parameterValueLen) {
+      parameterNameLen = -4;
+    }
+
+    int size =
+#endif
+
+      sprintf(cmd, cmdFmt,
 	    fBaseURL,
-	    ++fCSeq,
+	    fCSeq++,
 	    fLastSessionId,
 	    authenticatorStr,
 	    fUserAgentHeaderStr,
-	    parameterNameLen + parameterValueLen + 2, // the "+ 2" is for the \r\n after the parameter "name: value"
+// AS fix - please keep in ming size of ": "
+      parameterNameLen + parameterValueLen + 4, // the "+ 2" is for the \r\n after the parameter "name: value"
+      //parameterNameLen + parameterValueLen + 2, // the "+ 2" is for the \r\n after the parameter "name: value"
 	    parameterName, parameterValue);
     delete[] authenticatorStr;
 
+    // hack for KEP_ALIVE
+#if 1
+    if (parameterNameLen == -4) {
+      cmd[size - 4] = 0;
+    }
+#endif
+
     if (!sendRequest(cmd, "SET_PARAMETER")) break;
 
     // Get the response from the server:
     unsigned bytesRead; unsigned responseCode;
     char* firstLine; char* nextLineStart;
+// AS fix - authorization to be used correctly
+#if 1
+    if (!getResponse("SET_PARAMETER", bytesRead, responseCode, firstLine, nextLineStart, False)) break;
+    if (responseCode == 401) {
+      if (!Retry) {
+        delete[] cmd;
+        Retry++;
+        checkForAuthenticationFailure(responseCode, nextLineStart, &fCurrentAuthenticator);
+        goto rep;
+      } else {
+        break;
+      }
+      if (responseCode != 200) {
+        break;
+      }
+    }
+#else
     if (!getResponse("SET_PARAMETER", bytesRead, responseCode, firstLine, nextLineStart)) break;
+#endif
 
     delete[] cmd;
     return True;
@@ -1527,7 +1687,7 @@
       cmd = new char[cmdSize];
       sprintf(cmd, cmdFmt,
 	      fBaseURL,
-	      ++fCSeq,
+	      fCSeq++,
 	      fLastSessionId,
 	      authenticatorStr,
 	      fUserAgentHeaderStr,
@@ -1551,7 +1711,7 @@
       cmd = new char[cmdSize];
       sprintf(cmd, cmdFmt,
 	      fBaseURL,
-	      ++fCSeq,
+	      fCSeq++,
 	      fLastSessionId,
 	      authenticatorStr,
 	      fUserAgentHeaderStr);
@@ -1695,7 +1855,7 @@
     cmd = new char[cmdSize];
     sprintf(cmd, cmdFmt,
 	    sessURL,
-	    ++fCSeq,
+	    fCSeq++,
 	    fLastSessionId,
 	    authenticatorStr,
 	    fUserAgentHeaderStr);
@@ -1703,6 +1863,7 @@
 
     if (!sendRequest(cmd, "TEARDOWN")) break;
 
+// AS Fix for getting response on TEARDOWN, if any
     if (fTCPStreamIdCount == 0) { // When TCP streaming, don't look for a response
       // Get the response from the server:
       unsigned bytesRead; unsigned responseCode;
@@ -1713,8 +1874,8 @@
       MediaSubsessionIterator iter(session);
       MediaSubsession* subsession;
       while ((subsession = iter.next()) != NULL) {
-	delete[] (char*)subsession->sessionId;
-	subsession->sessionId = NULL;
+        delete[] (char*)subsession->sessionId;
+        subsession->sessionId = NULL;
       }
 
       delete[] fLastSessionId; fLastSessionId = NULL;
@@ -1765,7 +1926,7 @@
     cmd = new char[cmdSize];
     sprintf(cmd, cmdFmt,
 	    prefix, separator, suffix,
-	    ++fCSeq,
+	    fCSeq++,
 	    subsession.sessionId,
 	    authenticatorStr,
 	    fUserAgentHeaderStr);
@@ -1810,12 +1971,25 @@
     if (fInputSocketNum < 0) {
       // We don't yet have a TCP socket.  Set one up (blocking) now:
       fInputSocketNum = fOutputSocketNum
-	= setupStreamSocket(envir(), 0, False /* =>blocking */);
+	= setupStreamSocket(envir(), 0, False /* =>blocking */ 
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_TCP
+  , destAddress.GetAF()
+#endif
+  );
       if (fInputSocketNum < 0) break;
 
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6
+      fServerAddressFull = destAddress;
+      // do this deprecated staff, as i do not whant to change just everything
+      fServerAddress = *(unsigned*)(destAddress.data());
+#else
       // Connect to the remote endpoint:
       fServerAddress = *(unsigned*)(destAddress.data());
       MAKE_SOCKADDR_IN(remoteName, fServerAddress, htons(destPortNum));
+#endif
+
       //Start change for timeout on connect
 
 /*
@@ -1833,7 +2007,12 @@
         tvout.tv_usec = 0;
         makeSocketNonBlocking(fInputSocketNum);
       }
-      if (connect(fInputSocketNum, (struct sockaddr*) &remoteName, sizeof remoteName) != 0) {
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6
+      if (destAddress.Connect(fInputSocketNum, htons(destPortNum)) != 0) {
+#else
+      if (connect(fInputSocketNum, (struct sockaddr*) &remoteName, sizeof(remoteName)) != 0) {
+#endif
         if (envir().getErrno() != EINPROGRESS && envir().getErrno() != EWOULDBLOCK) {
           envir().setResultErrMsg("connect() failed: ");
           break;
@@ -1894,7 +2073,37 @@
       }
       ++from1;
     }
-
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6
+    char* to = &parseBuffer[0];
+    unsigned i;
+    if (*from == '[') // IPv6
+    {
+      //i++;
+      from++;
+      for (i = 0; i < parseBufferSize; ++i) {
+        if (*from == '\0' || *from == ']') {
+          // We've completed parsing the address
+          *to = '\0';
+          from++;
+          break;
+        }
+        *to++ = *from++;
+      }
+    }
+    else
+    {
+      for (i = 0; i < parseBufferSize; ++i) {
+        if (*from == '\0' || *from == ':' || *from == '/') {
+          // We've completed parsing the address
+          *to = '\0';
+          break;
+        }
+        *to++ = *from++;
+      }
+    }
+// AS fix for IPv6
+#else // LIVE_SUPPORT_IPV6
     char* to = &parseBuffer[0];
     unsigned i;
     for (i = 0; i < parseBufferSize; ++i) {
@@ -1905,6 +2114,9 @@
       }
       *to++ = *from++;
     }
+// AS fix for IPv6
+#endif // LIVE_SUPPORT_IPV6
+
     if (i == parseBufferSize) {
       env.setResultMsg("URL is too long");
       break;
@@ -1918,6 +2130,11 @@
     }
     address = *(addresses.firstAddress());
 
+#ifdef LIVE_SUPPORT_IPV6
+    // hack!!!
+    g_AF = address.GetAF();
+#endif
+
     portNum = 554; // default value
     char nextChar = *from;
     if (nextChar == ':') {
@@ -1991,6 +2208,41 @@
     // We've been provided a filled-in authenticator, so use it:
     char* authenticatorStr;
     if (authenticator->nonce() != NULL) { // Digest authentication
+// AS Fix for qop
+#ifdef SUPPORT_QOP
+      if (authenticator->qop())
+      {
+        char const* const authFmt =
+          "Authorization: Digest username=\"%s\", realm=\"%s\", "
+          "nonce=\"%s\", uri=\"%s\", qop=auth, nc=00000001, cnonce=\"%s\", response=\"%s\"\r\n";
+        char const* response = authenticator->computeDigestResponse(cmd, url);
+        unsigned authBufSize = strlen(authFmt)
+          + strlen(authenticator->username()) + strlen(authenticator->realm())
+          + strlen(authenticator->nonce()) + strlen(url) + strlen(authenticator->cnonce()) + strlen(response);
+        authenticatorStr = new char[authBufSize];
+        sprintf(authenticatorStr, authFmt,
+          authenticator->username(), authenticator->realm(),
+          authenticator->nonce(), url, authenticator->cnonce(), response);
+        authenticator->reclaimDigestResponse(response);
+      }
+      else
+      {
+      char const* const authFmt =
+	"Authorization: Digest username=\"%s\", realm=\"%s\", "
+	"nonce=\"%s\", uri=\"%s\", response=\"%s\"\r\n";
+      char const* response = authenticator->computeDigestResponse(cmd, url);
+      unsigned authBufSize = strlen(authFmt)
+	+ strlen(authenticator->username()) + strlen(authenticator->realm())
+	+ strlen(authenticator->nonce()) + strlen(url) + strlen(response);
+      authenticatorStr = new char[authBufSize];
+      sprintf(authenticatorStr, authFmt,
+	      authenticator->username(), authenticator->realm(),
+	      authenticator->nonce(), url, response);
+      authenticator->reclaimDigestResponse(response);
+      }
+
+// AS Fix for qop
+#else
       char const* const authFmt =
 	"Authorization: Digest username=\"%s\", realm=\"%s\", "
 	"nonce=\"%s\", uri=\"%s\", response=\"%s\"\r\n";
@@ -2003,6 +2255,8 @@
 	      authenticator->username(), authenticator->realm(),
 	      authenticator->nonce(), url, response);
       authenticator->reclaimDigestResponse(response);
+// AS Fix for qop
+#endif // SUPPORT_QOP
     } else { // Basic authentication
       char const* const authFmt = "Authorization: Basic %s\r\n";
 
@@ -2010,7 +2264,7 @@
       char* usernamePassword = new char[usernamePasswordLength+1];
       sprintf(usernamePassword, "%s:%s", authenticator->username(), authenticator->password());
 
-      char* response = base64Encode(usernamePassword, usernamePasswordLength);
+      char* response = base64Encode(usernamePassword, usernamePasswordLength, fBase64LineBreaks);
       unsigned const authBufSize = strlen(authFmt) + strlen(response) + 1;
       authenticatorStr = new char[authBufSize];
       sprintf(authenticatorStr, authFmt, response);
@@ -2038,20 +2292,43 @@
 
       nextLineStart = getLine(lineStart);
       if (lineStart[0] == '\0') break; // this is a blank line
+// AS Fix for qop
+#ifdef SUPPORT_QOP
+      char* realm = strDupSize(lineStart);
+      char* nonce = strDupSize(lineStart);
+      char* alg = strDupSize(lineStart);
+      char* qop = strDupSize(lineStart);
+
+      strcpy(alg, "md5");
+      *qop = 0;
 
+      Boolean foundAuthenticateHeader = False;
+      if (sscanf(lineStart, "WWW-Authenticate: Digest realm=\"%[^\"]\", nonce=\"%[^\"]\", algorithm=%[^,\"], qop=\"%[^\"]\"",
+        realm, nonce, alg, qop) >= 2) {
+          authenticator->setRealmAndNonce(realm, nonce);
+          if (qop && *qop)
+            authenticator->setQOP();
+          foundAuthenticateHeader = True;
+#else // SUPPORT_QOP
       char* realm = strDupSize(lineStart);
       char* nonce = strDupSize(lineStart);
+
       Boolean foundAuthenticateHeader = False;
       if (sscanf(lineStart, "WWW-Authenticate: Digest realm=\"%[^\"]\", nonce=\"%[^\"]\"",
 		 realm, nonce) == 2) {
 	authenticator->setRealmAndNonce(realm, nonce);
 	foundAuthenticateHeader = True;
+#endif // SUPPORT_QOP
       } else if (sscanf(lineStart, "WWW-Authenticate: Basic realm=\"%[^\"]\"",
 		 realm) == 1) {
 	authenticator->setRealmAndNonce(realm, NULL); // Basic authentication
 	foundAuthenticateHeader = True;
       }
       delete[] realm; delete[] nonce;
+// AS Fix for qop
+#ifdef SUPPORT_QOP
+      delete[] alg; delete[] qop;
+#endif // SUPPORT_QOP
       if (foundAuthenticateHeader) break;
     }
   }
@@ -2063,16 +2340,30 @@
     envir() << "Sending request: " << requestString << "\n";
   }
 
+// AS fix: getting RTSP request
+  if (requestString &&
+    (strstr(tag, "OPTIONS") != NULL ||
+     strstr(tag, "DESCRIBE") != NULL ||
+     strstr(tag, "SETUP") != NULL ||
+     strstr(tag, "PLAY") != NULL ||
+     strstr(tag, "PAUSE") != NULL ||
+     strstr(tag, "TEARDOWN") != NULL
+    )
+     )
+  {
+    strcpy(fRtspRequestBuffer, requestString);
+  }
+
   char* newRequestString = NULL;
   if (fTunnelOverHTTPPortNum != 0 && base64EncodeIfOverHTTP) {
-    requestString = newRequestString = base64Encode(requestString, strlen(requestString));
+    requestString = newRequestString = base64Encode(requestString, strlen(requestString), fBase64LineBreaks);
     if (fVerbosityLevel >= 1) {
       envir() << "\tThe request was base-64 encoded to: " << requestString << "\n\n";
     }
   }
-
+  
   Boolean result
-    = send(fOutputSocketNum, requestString, strlen(requestString), 0) >= 0;
+    = send(fOutputSocketNum, requestString, strlen(requestString), 0) >= 0; 
   delete[] newRequestString;
 
   if (!result) {
@@ -2086,6 +2377,8 @@
   }
   return result;
 }
+// AS hack
+unsigned lastResponseCode;
 
 Boolean RTSPClient::getResponse(char const* tag,
 				unsigned& bytesRead, unsigned& responseCode,
@@ -2094,6 +2387,30 @@
   do {
     char* readBuf = fResponseBuffer;
     bytesRead = getResponse1(readBuf, fResponseBufferSize);
+
+// AS fix: getting RTSP response
+    if ( (bytesRead > 0 && (strstr(tag, "DESCRIBE") != NULL)) || 
+         (fSocketReadAllMode && bytesRead > 0 && (strstr(tag, "OPTIONS") != NULL || 
+          strstr(tag, "SETUP") != NULL || strstr(tag, "PLAY") != NULL || 
+          strstr(tag, "PAUSE") != NULL || strstr(tag, "TEARDOWN") != NULL)) 
+        ) 
+    {
+      if (char *p1 = strstr(readBuf, "RTSP/"))
+      {
+        strcpy(fRtspResponseBuffer, readBuf);
+      } else {
+        fRtspResponseBuffer[0] = '\0';
+      }
+    } else {
+      fRtspResponseBuffer[0] = '\0';
+    }
+
+    if (fSocketReadAllMode && bytesRead > 0) {
+      strcpy(fResponseBuffer2, readBuf);
+    } else if (bytesRead == 0) {
+      fResponseBuffer2[0] = '\0';
+    }
+
     if (bytesRead == 0) {
       envir().setResultErrMsg("Failed to read response: ");
       break;
@@ -2103,6 +2420,17 @@
     }
 
     firstLine = readBuf;
+    // AS fix
+    // fix for some client/server scenario
+    // see http://stackoverflow.com/questions/259038/rtsp-over-http-over-a-proxy
+    // see https://helixcommunity.org/viewcvs/protocol/common/util/hxcloakedsocket.cpp?view=markup
+    // see http://helix-player.sourcearchive.com/documentation/1.0.4-1sarge2/httpclk_8h-source.html
+    // see http://helix-player.sourcearchive.com/documentation/1.0.4-1sarge2/hxcloakedtcp_8cpp-source.html
+    if ((firstLine[0] == 'H') &&
+        (firstLine[1] == 2))
+    {
+      firstLine += 4;
+    }
     nextLineStart = getLine(firstLine);
     if (!parseResponseCode(firstLine, responseCode)) break;
 
@@ -2112,13 +2440,41 @@
       break;
     }
 
+    // AS hack
+    lastResponseCode = responseCode;
     return True;
   } while (0);
 
+  // AS hack
+  lastResponseCode = responseCode;
   // An error occurred:
   return False;
 }
 
+int RTSPClient::readSocketByte(UsageEnvironment& env,
+      int socket, unsigned char* buffer, unsigned bufferSize,
+      struct sockaddr_in& fromAddress, struct timeval* timeout)
+{
+  if (!fSocketReadAllMode) {
+   return readSocket(env, socket, buffer, bufferSize, fromAddress, NULL);  
+  }
+  int Ret = -1, Err = 0;
+  struct timeval timeoutRead;
+  timeoutRead.tv_sec = 1; 
+  timeoutRead.tv_usec = 0;
+  int n = 5;
+  while (--n && (Ret = readSocket(env, socket, buffer, bufferSize, fromAddress, &timeoutRead)) != 1) {
+    if (Ret == -WSAEWOULDBLOCK || (Err = WSAGetLastError()) == WSAEWOULDBLOCK)
+      continue;
+  }
+  return Ret;
+}
+
+int QuickSocketNumber;
+unsigned char QuickstreamChannelId;
+unsigned short Quicksize;
+
+
 unsigned RTSPClient::getResponse1(char*& responseBuffer,
 				  unsigned responseBufferSize) {
   struct sockaddr_in fromAddress;
@@ -2134,8 +2490,9 @@
     unsigned char firstByte;
     struct timeval timeout;
     timeout.tv_sec = 30; timeout.tv_usec = 0;
-    if (readSocket(envir(), fInputSocketNum, &firstByte, 1, fromAddress, &timeout)
-	!= 1) break;
+
+    if (readSocketByte(envir(), fInputSocketNum, &firstByte, 1, fromAddress, &timeout) != 1) break;
+
     if (firstByte != '$') {
       // Normal case: This is the start of a regular response; use it:
       responseBuffer[0] = firstByte;
@@ -2144,37 +2501,47 @@
     } else {
       // This is an interleaved packet; read and discard it:
       unsigned char streamChannelId;
-      if (readSocket(envir(), fInputSocketNum, &streamChannelId, 1, fromAddress)
-	  != 1) break;
+      if (readSocketByte(envir(), fInputSocketNum, &streamChannelId, 1, fromAddress) != 1) break;
 
       unsigned short size;
-      if (readSocketExact(envir(), fInputSocketNum, (unsigned char*)&size, 2,
-		     fromAddress) != 2) break;
+      if (readSocketExact(envir(), fInputSocketNum, (unsigned char*)&size, 2, fromAddress) != 2) break;
       size = ntohs(size);
       if (fVerbosityLevel >= 1) {
-	envir() << "Discarding interleaved RTP or RTCP packet ("
-		<< size << " bytes, channel id "
-		<< streamChannelId << ")\n";
+	      envir() << "Discarding interleaved RTP or RTCP packet ("
+		    << size << " bytes, channel id "
+		    << streamChannelId << ")\n";
       }
 
+      if (!Quicksize) {
+        QuickSocketNumber = fInputSocketNum;
+	QuickstreamChannelId = streamChannelId;
+	Quicksize = size;
+	int wait = 20;
+        while (wait --> 0) {
+	  if (!Quicksize)
+		break;
+	  Sleep(100);
+	}
+      	if (!Quicksize) success = True;
+        break;
+      } 
       unsigned char* tmpBuffer = new unsigned char[size];
       if (tmpBuffer == NULL) break;
       unsigned bytesRead = 0;
       unsigned bytesToRead = size;
       int curBytesRead;
-      while ((curBytesRead = readSocket(envir(), fInputSocketNum,
-					&tmpBuffer[bytesRead], bytesToRead,
-					fromAddress)) > 0) {
-	bytesRead += curBytesRead;
-	if (bytesRead >= size) break;
-	bytesToRead -= curBytesRead;
+      while ((curBytesRead = readSocket(envir(), fInputSocketNum, &tmpBuffer[bytesRead], bytesToRead, fromAddress)) > 0) {
+	      bytesRead += curBytesRead;
+	      if (bytesRead >= size) break;
+	      bytesToRead -= curBytesRead;
       }
+      // do something if buffer is sufficient and not used
       delete[] tmpBuffer;
       if (bytesRead != size) break;
-
       success = True;
     }
   }
+
   if (!success) return 0;
 
   // Keep reading data from the socket until we see "\r\n\r\n" (except
@@ -2183,38 +2550,63 @@
   char* p = responseBuffer;
   Boolean haveSeenNonCRLF = False;
   int bytesRead = 1; // because we've already read the first byte
+
   while (bytesRead < (int)responseBufferSize) {
-    int bytesReadNow
-      = readSocket(envir(), fInputSocketNum,
+    int bytesReadNow = readSocket(envir(), fInputSocketNum,
 		   (unsigned char*)(responseBuffer+bytesRead),
-		   1, fromAddress);
+       fSocketReadAllMode ? responseBufferSize - bytesRead : 1, 
+       fromAddress);
+
     if (bytesReadNow <= 0) {
+      if (fSocketReadAllMode && bytesReadNow == -WSAEWOULDBLOCK) continue;
       envir().setResultMsg("RTSP response was truncated");
       break;
     }
+
     bytesRead += bytesReadNow;
 
+    if (fSocketReadAllMode) {
+      char Tmp = responseBuffer[bytesRead];
+      responseBuffer[bytesRead] = '\0';
+      if (*p == '\0') {
+        *p = 'R';
+      }
+      char *EndStr = NULL;
+      if (EndStr = strstr(p, "\r\n\r\n")) {
+        *(EndStr + 4) = '\0';
+      } else if (EndStr = strstr(p, "\r\r")) {
+        *(EndStr + 2) = '\0';
+      } else if (EndStr = strstr(p, "\n\n")) {
+        *(EndStr + 2) = '\0';
+      } else {
+        responseBuffer[bytesRead] = Tmp;
+        continue;
+      }
+      return strlen(responseBuffer);
+    }
+
     // Check whether we have "\r\n\r\n" (or "\r\r" or "\n\n"):
-    char* lastToCheck = responseBuffer+bytesRead-4;
+    char* lastToCheck = responseBuffer + bytesRead - 4;
     if (lastToCheck < responseBuffer) continue;
+    
     for (; p <= lastToCheck; ++p) {
       if (haveSeenNonCRLF) {
-	if ((*p == '\r' && *(p+1) == '\n' && *(p+2) == '\r' && *(p+3) == '\n')
-	    || (*(p+2) == '\r' && *(p+3) == '\r')
-	    || (*(p+2) == '\n' && *(p+3) == '\n')) {
-	  responseBuffer[bytesRead] = '\0';
-
-	  // Before returning, trim any \r or \n from the start:
-	  while (*responseBuffer == '\r' || *responseBuffer == '\n') {
-	    ++responseBuffer;
-	    --bytesRead;
-	  }
-	  return bytesRead;
-	}
+	      if ((*p == '\r' && *(p+1) == '\n' && *(p+2) == '\r' && *(p+3) == '\n')
+	          || (*(p+2) == '\r' && *(p+3) == '\r')
+	          || (*(p+2) == '\n' && *(p+3) == '\n')) {
+	            responseBuffer[bytesRead] = '\0';
+
+	            // Before returning, trim any \r or \n from the start:
+	            while (*responseBuffer == '\r' || *responseBuffer == '\n') {
+	              ++responseBuffer;
+	              --bytesRead;
+	            }
+	            return bytesRead;
+	      }
       } else {
-	if (*p != '\r' && *p != '\n') {
-	  haveSeenNonCRLF = True;
-	}
+	      if (*p != '\r' && *p != '\n') {
+	        haveSeenNonCRLF = True;
+	      }
       }
     }
   }
@@ -2431,6 +2823,7 @@
 	    fUserAgentHeaderStr,
 	    sessionCookie);
     delete[] authenticatorStr;
+
     if (!sendRequest(cmd, "HTTP GET", False/*don't base64-encode*/)) break;
 
     // Get the response from the server:
@@ -2438,6 +2831,7 @@
     char* firstLine; char* nextLineStart;
     if (!getResponse("HTTP GET", bytesRead, responseCode, firstLine, nextLineStart,
 		     False /*don't check for response code 200*/)) break;
+
     if (responseCode != 200) {
       checkForAuthenticationFailure(responseCode, nextLineStart, authenticator);
       envir().setResultMsg("cannot handle HTTP GET response: ", firstLine);
@@ -2447,13 +2841,24 @@
     // Next, set up a second TCP connection (to the same server & port as before)
     // for the HTTP-tunneled client->server link.  All future output will be to
     // this socket.
-    fOutputSocketNum = setupStreamSocket(envir(), 0, False /* =>blocking */);
+    fOutputSocketNum = setupStreamSocket(envir(), 0, False /* =>blocking */
+
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6_TCP
+      , fServerAddressFull.GetAF()
+#endif
+      );
     if (fOutputSocketNum < 0) break;
 
     // Connect to the remote endpoint:
+// AS fix for IPv6
+#ifdef LIVE_SUPPORT_IPV6
+    if (fServerAddressFull.Connect(fOutputSocketNum,htons(fTunnelOverHTTPPortNum)) != 0) {
+#else
     MAKE_SOCKADDR_IN(remoteName, fServerAddress, htons(fTunnelOverHTTPPortNum));
     if (connect(fOutputSocketNum,
 		(struct sockaddr*)&remoteName, sizeof remoteName) != 0) {
+#endif
       envir().setResultErrMsg("connect() failed: ");
       break;
     }
@@ -2488,6 +2893,8 @@
     // Note that there's no response to the "POST".
 
     delete[] cmd;
+    // AS hack for BOSCH
+    Sleep(500);
     return True;
   } while (0);
 
@@ -2504,7 +2911,11 @@
 void RTSPClient::incomingRequestHandler1() {
   unsigned bytesRead;
   char* readBuf = fResponseBuffer;
+
+  EnterCriticalSection(&fCriticalSection);
   bytesRead = getResponse1(readBuf, fResponseBufferSize);
+  LeaveCriticalSection(&fCriticalSection);
+
   if (bytesRead == 0) {
     envir().setResultMsg("Failed to read response: Connection was closed by the remote host.");
     envir().taskScheduler().turnOffBackgroundReadHandling(fInputSocketNum); // because the connection died
